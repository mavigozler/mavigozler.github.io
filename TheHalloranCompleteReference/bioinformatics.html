<!DOCTYPE html>
<html lang="en">
<head>
<title>Notes on Bioinformatics</title>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	<link href="./stdcss/std.css" rel="stylesheet">
	<style>
		body {
			background-color: #e8ffe8;
		}

		td ul {
			margin-top: 0;
		}

		.definition {
			width: 75%;
			font: normal 100% 'Courier New', Courier, monospace;
		}

		a {
			color: red;
		}

		a:hover {
			color: green;
		}

		.left {
			text-align: left ! important;
		}

		.eqnserif,
		.eqnserif TD {
			background: none;
			text-align: center;
			padding: 0;
			font: normal 110% 'Times New Roman', 'Times Roman', Times, serif;
		}

		.question {
			font: normal 90% Arial, Helvetica, Tahoma, sans-serif;
			margin: 1em 3%;
		}

		.answer {
			font: normal 100% "Century Schoolbook", Bookman, "Bookman Old Style",
				"Times New Roman", "Times Roman", Times, serif;
		}

		.numer {
			border-bottom: 1px solid black;
		}

		caption {
			margin-top: 1em;
		}

		.TD6 td {
			width: 6em;
		}

		#quick-ref {
			border: 1px solid black;
			background-color: white;
			padding: 1em 2em;
		}

		#quick-ref h1 {
			color: black;
			font: bold 110% Tahoma, Arial, sans-serif;
		}

		#quick-ref h2 {
			color: navy;
			font: bold 100% "Arial Narrow", Helvetica, sans-serif;
		}

		#quick-ref h3 {
			color: green;
			font: bold 90% "MS Sans Serif", "Lucida Sans", Helvetica, sans-serif;
		}

		#quick-ref ul {
			margin-top: 0;
		}

		#quick-ref div {
			border: 1px solid blue;
			padding: 0.3em 0.5em;
		}

		#submission-form {
			white-space: pre;
			font: normal 85% 'Courier New', Courier, monospace;
			padding: 1em 3em;
			border: 1px solid black;
			background-color: white;
		}

		.scoring-matrix td,
		.scoring-matrix th {
			width: 2em;
		}

		pre {
			margin-top: 0;
			font-size: 83%;
		}
	</style>
</head>
<body>
	<p id="title">
		Bioinformatics
	</p>

	<p id="subtitle">
		Notes
	</p>

	<hr>
	<h1>Definitions: What Is Bioinformatics?</h1>
	<p class="definition">
		the collection, classification, storage, and analysis of biochemical and
		biological information using computers especially as applied to molecular
		genetics and genomics</p>

	<p>
		— <a href="http://www.merriam-webster.com/dictionary/bioinformatics">Merriam-Webster.com</a> (2 June 2011)</p>


	<p class="definition">
		There is still disagreement over the definition of bioinformatics.
		At its broadest, the term includes any application of computational methods
		to biological problems, from statistical genetics to the design of man–machine
		interfaces. In common usage most people assume <q>bioinformatics</q> to mean
		<q>computational molecular biology.</q> For the majority of syllabuses
		in European and U.S. higher education, this narrower definition is preferred.
	</p>
	<p>
		— D. Counsell (2003) <i>Briefings in Bioinformatics</i> <b>4</b>: 7-21</p>

	<p class="definition">
		[B]ioinformatics [is defined] as a scientific field that solves problems
		in the biological sciences using computer science concepts and methods.</p>
	<p>
		— I. Koch, G Fuellen (2008) <i>Briefings in Bioinformatics</i>
		<b>9</b>: 232-242
	</p>

	<h1>A Curriculum in Bioinformatics</h1>
	<p>
		An editorial in <i>Bioinformatics</i> <b>14:</b> 549-550, 1998, proposed a
		curriculum for graduate level (MS, PhD) students. MS level are competent
		practitioners while PhD level expand the field with novel discovery. The
		grounding requires physics, chemistry, and biology in undergraduate coursework
		with computer programming, applied mathematics, and basic statistics. Graduate
		work requires computational biology or bioinformatics. Statistics work should
		include probability theory, experimental statistical design and analysis, and
		stochastic processes. Courses in ethics are essential, including privacy and
		security. Core bioinformatics courses include (not limiting):</p>
	<ul>
		<li>Pairwise sequence alignment (dynamic programming, heuristic methods,
			similarity matrices)</li>
		<li>Multiple sequence alignment</li>
		<li>Hidden Markov Models (construction, use in alignment, prediction)</li>
		<li>Phylogenetic Trees</li>
		<li>Fragment and map assembly and combinatorial approaches to sequencing</li>
		<li>RNA Secondary structure prediction</li>
		<li>Sequence feature extraction/annotation</li>
		<li>Protein homology modeling</li>
		<li>Protein threading</li>
		<li>Protein molecular dynamics</li>
		<li>Protein ab initio structure prediction</li>
		<li>Integration of molecular biology databases</li>
		<li>Support of laboratory biology (sequencing, structure determination,
			DNA arrays, etc.)</li>
		<li>Design and implementation of biological databases/knowledge bases</li>
	</ul>
	<p>And computer science and statistics courses should include the introduction
		to key technologies:</p>
	<ul>
		<li>Optimization (Expectation Maximization, Monte Carlo, Simulated Annealing,
			gradient-based methods)</li>
		<li>Dynamic programming</li>
		<li>Bounded search algorithms</li>
		<li>Cluster analysis</li>
		<li>Classification</li>
		<li>Neural Networks</li>
		<li>Genetic Algorithms</li>
		<li>Bayesian Inference</li>
		<li>Stochastic Context Free Grammars</li>
	</ul>
	<p>
		In the UK, most bioinformatics programs are offered as graduate level
		curricula (leading to an MSc. usually). A few universities actually offer
		it at the undergraduate level (BSc). D. Counsell's paper cited above gives
		a thorough description of the programs at all UK higher education institutions
		as of 2003.
	</p>
	<h2>Bioinformatics Education in Germany</h2>
	<p>
		In Germany as of 2008, both BSc and MSc programs at several universities were
		offered. Bioinformatics has three subfields: sequence-related analysis,
		structure-related analysis, and computational systems biology (analysis of
		molecular networks). Learning modules includes use of statistics in
		sequence/structure analysis and microarray data evaluation, combinatorics
		in phylogenetic tree inference, and algebra/numerics in quantitative approaches.</p>
	<p><b>Bachelor's Level</b>. All of bioinformatics is highly multidisciplinary.
		As such courses in biology (lecture and laboratory) are required. In the
		informatics/computer science area:</p>
	<ul>
		<li>principles of database design</li>
		<li>algorithm design and analysis, with focus on pattern-matching algorithms</li>
		<li>dynamic programming</li>
		<li>graph algorithms</li>
		<li>programming paradigms and skill:
			<ul>
				<li>scripting languages: Perl, Python</li>
				<li>higher level programming languages: C/C++, Java</li>
			</ul>
		</li>
	</ul>
	<p>Mathematics includes:</p>
	<ul>
		<li>statistics</li>
		<li>linea algebra</li>
		<li>graph theory</li>
	</ul>
	<p><b>Master's Level</b>. This is intended as a <q>depth</q> involving
		specialization beyond the bachelor's level.</p>

	<h2>What Every Biologist Should Know</h2>
	<p>Cattley and Arthur (<i>Brief. Bioinform.</i> <b>8</b>: 457-465, 2007)
		assert that <q>at the most rudimentary level,</q> biologists should have
		a familiarity with how to access online repositories such as UniProt and
		GenBank, and how to use BLAST for DNA and protein sequence similarity
		searches. They should also be aware of principles of multiple sequence
		alignment, PCR primer design, restriction mapping, evolutionary phylogeny,
		gene detection, microarray analysis, protein structure and function prediction,
		proteomic protein identification and characterization, motif searching,
		and sequence assembly.</p>

	<h1>The Bio in Bioinformatics</h1>
	<h2>DNA</h2>
	<p>The bioinformatic scientist should be aware that:</p>
	<ul>
		<li>DNA is composed of four bases <b>adenine, guanine, cytosine, thymine</b>
			paired on a deoxyribosephosphate chain. Purines (A and G) are paired to
			pyrimidines (T and C) respectively. There is a strandedness with a 3- and
			5-prime orientation.</li>
		<li>DNA is replicated by unwinding the helix combined with synthesis is a
			stranded manner: continuously on one strand and discontinuously on the other.
			A short nucleotide chain (<i>primer</i>) is required to initiate synthesis.</li>
		<li>DNA is structured into the living cell as a chromosome, and the total
			DNA in the cell comprises the genome. The human genome has about 3 billion
			bases distributed into 46 linear molecules all into chromosomes. There are
			22 different autosomes and an X and Y chromosome: their size ranges from
			50 to 250 million base pairs.</li>
		<li>In eukaryotes, gene organization includes intergenic (or intervening)
			sequences with many control regions or sites for protein binding for chromosome
			packaging. Within the gene, transcription occurs with production of a primary
			or pre-mRNA transcript, and from this, introns are removed to leave only
			exons, which are the translated sequences (this was discovered in 1977).
			Genes only make up 2-3% of the total amount of human DNA. Processing of the
			mRNA involves putting a poly-(A) tail and a 5'-mmm-G cap within the nucleus,
			and with intron removal in the cytoplasm. Introns are typically quite long
			(10,000 bp) while exons are often very short (200 bp).</li>
		<li>In prokaryotes (bacteria) and in many viruses, the coding part of DNA
			contains no introns and exons as in eukaryotes, in which the introns must be
			processed out to produce a mRNA that can be translated. In fact there is
			nucleus containing multiple chromosomes: bacteria typically have only one
			chromosome which is circular and it mixes with the cytoplasm containing
			the components for translation (mainly, but not exclusively ribosomes).
			In fact, the transcription of a gene from the single (DNA) chromosome is
			typically <q>coupled</q> or <i>synchronous</i> to its translation. While
			an RNA polymerase is often actively transcribing a gene, the freshly made
			5′ end of the RNA transcript is being translated with an attached
			ribosome. This is because there is no physical separation or compartmentalization
			of the transcription/translation apparatus as there is in eukaryotes</li>
		<li>Because DNA is double-stranded, and the nature of transcription is
			such that only one of the strands is transcribed to make a complementary
			sequence of RNA, the strand of DNA that makes the complement as an RNA
			sequence is called the <i>sense</i> strand, and the strand <em>not</em>
			read by the RNA polymerase is called the <i>anti-sense</i> strand.
			This does mean that there is only strand in the entire length of the chromosome
			that is the sense strand: it only refers to a gene of interest on that
			chromosome, whose coding comes from one strand or the other.</li>
	</ul>
	<h3>Mutations</h3>
	<p>Changes in heritability and thus of the DNA sequence cover the subject of
		mutation and polymorphism.</p>

	<h2>RNA</h2>

	<p>
		RNA is composed typically of four bases, of which three are in common
		with DNA. While adenine (A), cytosine (C), and guanine (G) are in both RNA
		and DNA, the base thymine (T) is found in DNA while uracil (U). That is
		where there is uracil in RNA, it represents a thymine in DNA during
		its transcription. During transcription, the RNA polymerase matches
		a base C to the base G in DNA, C for RNA to G in DNA, A for RNA to T in DNA,
		and U for RNA to A in DNA.</p>
	<p>
		RNA transcribed from DNA will fall into three different classes, which all
		have different biological roles, although in most cases, all the RNA is involved
		the basic purpose of translation, which is the production of the genome into the
		proteome. Ribosomal RNA (rRNA) will fold and associate with special proteins
		that will form the ribosome. The ribosome is an assembly of proteins and rRNA
		necessary for translating the second class of RNA, messenger RNA
		(mRNA), which holds the actual code for the protein, into that protein.
		Required also for that translation is a special short sequence of RNA called
		transfer RNA (tRNA): its 3′ end has been <q>charged</q> (or complexed)
		with one of the 20 amino acids matched to a special short sequence of the
		tRNA called the anti-codon, and the ribosome will assist in matching the
		correct anti-codon of tRNA to the 3 bases of the mRNA, the codon, and
		link the amino acid of tRNA to an elongating polymer of amino acids being
		formed by ribosome and mRNA which become a functional protein.</p>
	<p>
		All the RNA classes described here are single-stranded, although the single
		strand can form loops and different segments of the strand pair with other
		segments using the same chemistry that cause two strands of DNA to associate</p>

	<h2>Issues in Bioinformatics</h2>
	<p>Among the issues in bioinformatics:</p>

	<ul>
		<li><b>Gene Finding</b>. This is the most urgent. The signatures indicating
			real genes must be known and understood in order to detect what are real genes.</li>
		<li><b>Sequence Alignment</b>. This concerns finding the best sequence
			matching of two sequences of DNA or protein. A good algorithm indicates use
			of an operation such as making deletions or mismatches or frameshifts or
			opening gaps and the penalty to be paid. Multiple sequence alignment attempts
			to do this with more than two sequences.</li>
		<li><b>Genome Rearrangement</b>. Given two permutations of a set of genomic
			segments, what are the minimal set of operations to permute one into identity
			with the other. This problem concerns rearrangement events which occur about
			once every 5-10 million years.</li>
		<li>A protein's function is determined by its 3D structure, and so predicting
			3D function can help to elucidate a role of a protein. We are given only an
			amino acid sequence and the chemistry of each amino acid, and in combination
			with the amino acids. Among the techniques available include:
			<ul>
				<li><b>Homology modeling</b>. Databases are searched of proteins showing
					sequence similarity; generally where ≥ 30% sequence identity is found
					we can assume possible functional similarities.</li>
				<li><b>Threading</b>. Known structures are classed into families having
					similar foldings.</li>
			</ul>
		</li>
	</ul>

	<h1>Laboratory Management of Original Data</h1>
	<p>
		For laboratories generating original data in DNA or protein sequencing, they
		should be aware of methods and software used in data management. The standard
		sequencing tool for DNA is the dideoxy method with fluorscently labeled
		dideoxy terminators. The different lengths are then resolved by capilllary
		electrophoresis with polymerized gel beds and the end of the capillary uses
		lasers to detect the four different dyes and mark off the bases. The
		short runs of sequences (from 500 to 1000 bases) for genome-based analyses
		can be assembled using <a href="http://www.phrap.org/phredphrapconsed.html">PHRED,
			PHRAP and CONSED</a>.</p>
	<ul>
		<li>PHRED will take the fluorscent raw signal trace files from many instruments
			that perform the DNA sequencing, and calculate the <em>quality value</em> (Q)
			for each base. The equation is <i>Q</i> = −10 log <i>P</i><sub>e</sub>,
			where <i>P</i><sub>e</sub> is the probability of error in making a particular
			call for a base. The code for PHRED is in C and must be compiled.</li>
		<li>PHRAP takes the many trace files analyzed by PHRED and assembles the
			contigs in shotgun data. In addition, the program <b>cross_match</b> helps
			to discern insert sequence from vector sequences that were used for the sequencing.
			The program <b>swat</b> which takes one or more DNA or protein query sequences
			or query profile and searches a database, using either Smith-Waterman or
			Needleman-Wunsch with linear (affine) gap penalties.</li>
		<li>CONSED is for viewing, editing, and finishing PHRAP-made assemblies.
			Its features include picking primers and templates, suggesting additional
			sequencing reactions.</li>
	</ul>

	<h1 id="internet">The Internet</h1>
	<p>
		Networks and networks of networks (internetworks and super networks,
		and the Internet) make bioinformatics possible on a grand scale.
		Many bioinformatics books talk about the history of the Internet,
		speed of connections, who provides service and who provides content.
		The importance of email, of (Usenet) newsgroups (NNTP servers) providing
		<q>public email</q>, of file transfers (ftp, tftp), of the World Wide Web
		and particular specific content of relevance to bioinformatics is discussed
		in these books.
	</p>


	<h1>About Databases</h1>
	<p>
		Databases are fundamental to bioinformatics. A large amount of raw and
		processed data are produced, created or derived in high throughput systems
		biology and other biomedical research. Sequences of DNA, RNA, proteins,
		and structures of proteins and metabolites are identified, with details
		(<q>annotations</q>) about the type of organism and tissues or cells
		of that organism (if multicellular) from which the data are obtained.
		All of these data are submitted in a specialized format with minimum
		requirements to mostly well known databases. So it is important to know
		what a database is.</p>
	<p>
		Databases are composed of <b>records</b>. A record is an <i>entry</i> in the
		database. Records are composed of <b>fields</b>. Fields are specific
		characteristics of the record. A field can be considered a fundamental datum
		of many that compose the record. An example will serve to demonstrate this
		more clearly.</p>
	<p>
		Suppose a database is being created that holds DNA sequences of any kind
		determined experimentally. The creator of that database prepares a <i>form</i>
		for each scientist wishing to submit a sequence to the database. The entry
		form can be a paper printout, but more likely it will be a web interface.
		It may look something like this:</p>
	<div id="submission-form">
		Record ID: _______________________ <small>(office use only, do not complete)</small>
		Date Submitted: ____ / ____ / ______ <small>(office use only, do not complete)</small>
		Submitter: _______________________
		Submitter Organization: ______________________
		Published citation (if any): __________________ <small>use citation format</small>
		Organism: _______________________ <small>use taxonomic format</small>
		DNA sequence:
		<small>* use separate page
			* fixed pitch of line length 80 characters
			* only a,t,g,c characters
			* start at 5' of one strand only
			* submit only sequences where confirmatory complementary strand also sequenced</small>
	</div>
	<p>
		This is a rather primitive construction of a record entry for a database
		containing DNA sequences, but it shows the minimal essential elements. Each of
		the fill-in blanks effectively makes up one field of the record, the
		characteristics of that record. Some of the entries of the form are not to
		be completed by the submitter of the sequence but rather by the database
		administrators, such as a Record ID and Date Submitted. The Record ID is
		important and explained below. The Date Submitted is when the database
		administrator gets the completed form; it might be important in determining
		who has <i>priority</i> with respect to discovering a DNA sequence.
		The submitter might not be the discoverer of the sequence, although it might
		be required by the database administrators that submissions must be with the
		knowledge and approval of the discoverer(s). If the sequence was reported
		in a publication, that too would already be a determiner of priority, and
		an entry field is available for that too. And finally, the two very important
		entry fields are the organism the DNA came from and the DNA sequence.
		The form itself also has instructional prompts as how the submitter should
		submit entry fields in a certain format or style.</p>
	<p>
		When submission is reviewed and approved as correct in format and content,
		it then becomes part of the database.</p>
	<p>
		A set of records is created and accumulated, and many records can be
		presented in a tabular format. This is why records are organized in databases
		into <b>tables</b>. In fact, a database is technically <em>not</em> a table,
		but rather is a collection of many tables. Each table of records may be
		constructed from raw (or unique) data composed of fields not in the records
		of other tables. Tables in a database can be interconnected with each other
		in multiple ways. These kinds of interconnections are what makes up
		relational databases. These connections are through fields in the records
		of these tables that are copies of identifiers that allow the making of these
		connections. These special fields are basically <em>key fields</em>, or
		just <b>keys</b> that allow tables to be connected (related) to each other.</p>
	<p>
		<b>Rows and records, columns and fields</b>. Because a collection or set of
		records is intrinsically tabular as to their organization, and tables are
		composed of rows and columns, data records organized into tables are such that
		the <b>row</b> of a table becomes synonymous with a <b>record</b>, and the
		<b>column</b> of a table is really the <b>field</b> of a record.
	</p>
	<p>
		<b>Keys</b>. In database <q>science</q>, <b>keys</b> are the fields by
		which a record can be identified, traced, tracked, found in searches, whatever.
		The <b>primary key</b> is a field (often the first in field order) of a record
		that uniquely identifies. In the example above, it is the Record ID (the
		identification number of the record) of the record submitted. It may not
		be presented to the submitter immediately, because the submission may need
		checking by database administrators and controlled for approval. Once approved,
		a primary key will be assigned. This primary key may go by different names
		for those administering the database, but in database science, it is always
		identifiable as the primary key. An important characterstic of the
		primary key is that it must be unique: no two records can have the same
		primary key. Think of the primary key as an address of a house: the house
		is a record, and the address is its primary key. Can two houses have the
		same address? It is the address that is used to find the house, as the
		primary key is used to find the record.
	</p>
	<p>
		For the NCBI databases, they use the term <b>accession number</b> or
		<b>accession identifier</b>, since it is by this number or identifier that
		record is accessed.
	</p>
	<p>
		Another kind of key is a <b>foreign key</b>.</p>


	<h1>NCBI Data Model</h1>
	<p>[Notes from JM Ostell, SJ Wheelan, JA Kans, <q>The NCBI Data Model</q> in
		<a href="#baxevanis">Baxevanis</a>.]
	</p>
	<p>
		A model is often some kind of construct that describes a dynamic system.
		The NCBI model is intended provide rapid and useful database storage and
		access of sequence data and of software that analyzes it.</p>
	<p>
		GenBank flat files concentrate on DNA sequences while protein databases
		focus on the protein, often with a loose connection to the gene involved.</p>
	<p>
		The NCBI model ensures that a DNA sequence and protein sequence are involved
		(a <i>nuc-prot</i> set).
		Using BLAST searches through the protein sequence is easier since the
		DNA sequence is not lost.</p>
	<p>
		Problems with GenBank information include the way parts of a gene are
		related to one another. Exons are connected as <b>SEGMENTS</b> in a
		series, which are connected to one another using an algorithm which
		employs a term <b>LOCUS</b>. Segment (gene or locus) names are assumed
		to be alphabetic characters (what if they are numbers?) and the
		naming in the LOCUS algorithm is &lt;segment-name&gt;<i>n</i>, where
		<i>n</i> is the ordinal number of the segment. Very little information
		about the exons (e.g., bp distance between each other or intron size)
		is given. The EMBL database does not even provide this information.
		GenBank, EMBL, and DDBJ recently agreed to add information in a CON
		record (CONtig or CONtiguous).
	</p>
	<p>
		The NCBI information is more annotated with accession number, citiations,
		comments.</p>

	<h2>Genomics Databases</h2>
	<p>
		<b>GenBank</b>. The NCBI, part of the National Institutes of Health (NIH),
		maintains a database that it calls <b>GenBank</b>. (The part <q>Bank</q> derives
		from <b>databank</b>, a synonym for database that is actually used by the
		British instead of database. So think of GenBank as meaning <q>Genomics
			Databank/Database</q> or <q>Genome Databank/Database</q> or <q>Gene
			Databank/Database.</q> It is better to think of it as the first, since it
		contains DNA sequences of any kind, whether they are whole genomes, sequences
		corresponding to genes, or sequences whose biological organization is not
		entirely understood. The NCBI takes a GenBank submission and its bioinformatics
		specialists over time may discover that the sequence has a known functional
		role, and may include a relational accession number that ties it to a derivative
		database (described in detail below).
	</p>
	<p>
		<b>EMBL Data Library</b>. The European Molecular Biology Laboratory (EMBL)
		is a network of laboratory sites in five different geographic locations,
		although they are a collaboration between 20 European nations and Australia.
		Their Data Library includes a database containing sequences of nucleotides
		and amino acids. By agreement, their database is unified with the GenBank
		database.
	</p>
	<p>
		<b>DDBJ</b>. The DNA Data Bank of Japan (DDBJ) is curated and maintained by
		the National Institute of Genetics in Japan. It too is a portal for the
		submission of DNA sequence data.
	</p>
	<p>
		All three of these databases are operated and maintained by government funds
		of developed world governments, and the data are available to the entire
		world without fee through the Internet. All of the databases are updated
		to be identical on a daily basis.</p>

	<h2>Derivative Databases</h2>
	<p>
		NCBI actually takes the GenBank data and puts it into a database called
		<b>Nucleotide</b>. If it has a DNA or RNA sequence, it gets a record in
		<b>Nucleotide</b> automatically.
	</p>
	<p>
		Now suppose that DNA sequence is a whole genome. Then it gets a record
		in the <b>Genome</b> database. Actually, the Genome database record in one
		of the fields (namely the <i>Sequence</i> field) will point to the Sequence
		field of the Nucleotide database (this is the basic nature of the relational
		database: it references the original data without needing to copy it
		in case changes are made to the data in a field). If genes have been
		identified in the sequence, then each gene will get a record in the
		<b>Gene</b> database at NCBI.
	</p>

	<ul>
		<li><b>dbEST</b>
			<br>Expressed sequence tags are short pieces of sequenced cDNA, usually about
the length of what is possible for a single sequencing reaction (between
500-1000 nt, depending on technologies and systems).  The sequence is the
complement of the mRNA strand, but should be equivalent to the sense
strand of the genome without the introns.  However, it is the sequence
of the sense strand at its 3′ end.
		</li>
		<li><b>dbSTS</b>
			<br> Sequence-tagged sites are unique sequences in the genome that can be
used specifically to help scientists amplify certain regions of the genome
for further study.
		</li>
		<li><b>dbGSS</b>
			<br> Special sequences all found in a genome that may have a special biological
role are can be used in mapping of the genome:  includes random <q>single
				pass read</q> GSS, cosmid/BAC/YAC end sequences, exon-trapped genomic sequences,
			Alu PCR sequences, transposon-tagged sequences
		</li>
		<li><b>dbHTGS</b>
			<br>
		</li>
	</ul>

	<h2>Submission</h2>
	<p>
		Each of the three databases has different submission forms and names for those
		submission forms. The entry fields have several validation checks before
		they are accepted.</p>

	<h2>Formats</h2>
	<ul>
		<li><b>GenBank</b>
			<br>
		</li>
		<li><b>FASTA</b>
			<br>
		</li>
		<li><b>EMBL</b>
			<br>
		</li>
	</ul>

	<h2>Accession Numbers or Identifiers</h2>
	<p>
		Consist of A55555 (one letter, five digits) or BC666666 (two letters, six
		digits).</p>

	<h1>Searching Identical or Similar Strings/Characters/Sequences</h1>
	<p>
		Finding sequences of DNA/RNA or protein that show significant identity
		or similarity implies that this similarity may have a possible significant
		importance to a function.</p>
	<p>
		<b>Similarity vs. homology</b>. Lesk says that similarity is about finding
		patterns of identity in sequences that do not need to consider the sources
		of those patterns of identity. That is, it is not necessary to speculate
		or require that the sequences originated from some biological ancestor.
		With homology, there is the imposition that the sources are related in that
		they descended (possibly diverged) from a common ancestor. Homology is
		usually inferred and tested from observations of high similarity, not the
		other way around.
	</p>

	<!-- =========================================================
      ALIGNMENT
============================================================== -->

	<h1>Sequence Alignment/Pairing Fundamentals</h1>

	<h2>The Dot Matrix</h2>
	<p>
		Gibbs and McIntyre (1970) developed a method of comparing sequences using
		a <b>dot matrix</b>. That is, the sequence of characters of two sequences
		were shown vertically and horizontally, and whenever there was a pairwise
		correspondence, a <q>dot</q> was marked in the two-dimensional grid.
		Whenever dots could be connected in a line on the diagonal, this represented
		a run of characters (subsequence) that were identical within the larger sequence.
		When the diagonal was shifted, it represented potential insertions or deletions
		of characters. Note this method is also called the <b>dot diagram</b>.</p>

	<h2>Dynamic Programming</h2>
	<p>
		The most ideal method is an <em>optimal alignment</em> in which sequences are
		shifted one at a time and examined for insertions and deletions. But this
		takes extensive computational time. Needleman and Wunsch (1970) developed
		a method beginning at end of each sequence and moving ahead a pair at a time,
		allowing for match and mismatched pairs or extra characters (insertions and
		deletions, or gaps), which is called <b>dynamic programming</b>. In addition
		to sequence shifting and matching, they had a scoring system.
	</p>
	<table>
		<tbody>
			<tr>
				<th> </th>
				<th>G</th>
				<th>A</th>
				<th>T</th>
				<th>C</th>
				<th>T</th>
				<th>A</th>
			</tr>
			<tr>
				<th>G</th>
				<td>1</td>
				<td> </td>
				<td> </td>
				<td> </td>
				<td> </td>
				<td> </td></tr>
			<tr>
				<th>A</th>
				<td> </td>
				<td>2</td>
				<td> </td>
				<td> </td>
				<td> </td>
				<td>1</td></tr>
			<tr>
				<th>T</th>
				<td> </td>
				<td> </td>
				<td>3</td>
				<td> </td>
				<td>1</td>
				<td> </td></tr>
			<tr>
				<th>C</th>
				<td> </td>
				<td> </td>
				<td> </td>
				<td>4</td>
				<td> </td>
				<td> </td></tr>
			<tr>
				<th>A</th>
				<td> </td>
				<td>1</td>
				<td> </td>
				<td> </td>
				<td> </td>
				<td>5</td></tr>
		</tbody>
	</table>
	<p>
		In the table example, a score of 1 was placed at the intersecting cell wherever
		characters matched, and a score of 0 (not shown) where there was a mismatch.
		When the values 1 line up along a diagonal, they add to each other; thus a
		diagonal forms for a value of 4. A value of 5 is placed at last row and column
		but it required a gap introdction, so the total score would be 5 − a
		gap penalty. Because this sequence matching and scoring looks at the whole
		sequence, it is a kind of <em>global alignment</em>.</p>
	<p>
		Smith &amp; Waterman later developed a system that focuses on aligning
		subsets or subsequences rather than the whole, an algorithm for <em>local
			alignment</em>.</p>
	<p>
		<b>Similarity and Distance Scoring</b>. Similarity scoring has to do with
		evaluating matches, mismatches and the need to make matches through introducing
		gaps. Distance scoring is related with making character substitutions in the
		sequence in order to make matches, which is useful for predicting evolutionary
		distances; it is computed as sum of number of mismatches divided by total of
		matches and mismatches.
	</p>
	<p>
		Consider two sequences A [AGCDEVIG] and B [AGEYCDIIG] and they are aligned
		optimally as follows</p>
	<p style="font:bold 110% 'Miriam Fixed','Courier New';margin-left:5em;">
		A G _ _ C D E V I G <br>
A G E Y C D _ I I G</p>
	<p>
		In the example from above with 6 matches and 1 mismatch,
		similarity score = 6/7 = 0.86, while distance is 1/7 = 0.14. Note that the
		sum of the similarity and distance scores is 1. Consider also that the sum
		of the sequence lengths (8 + 9) equals twice number of matches plus mismatches
		plus number of gaps (deletions or insertions): 2 × (6 + 1) + 3 = 17.</p>
	<p>
		<b>Multiple Sequence Alignment</b>. Programs like GCG's PILEUP and CLUSTALW
		have been useful not only in aligning related sequences but eventually help
		to identify highly conserved regions of sequences. The programs PROFILE and
		POSITION-SPECIFIC SCORING MATRIX (PSSM) have been useful for this purpose.
	</p>
	<p>
		<b>Nucleotide secondary structure prediction</b>. Many nucleotide sequences
		feature biologically purposeful complementarity structures (stem-loops, hairpins,
		other annealing pairs)
	</p>

	<!-- =================================================================== -->
	<hr>

	<p>
		Condider two <dfn>strings</dfn>: <tt>acbcdb</tt> and <tt>cadbd</tt>. One major
		difference already seen is that one is 6 characters long, the other 5 characters,
		which would complicate an effort to align them. In the first attempt at a
		good aligment</p>
	<pre> a c - - b c d b
		- c a d b - d -
	</pre>
	<p>
		where <q>-</q> represents an attempt to space, or introduce a <dfn>gap</dfn>.
		The <dfn>goodness</dfn> of the alignment can be evaluated using a <dfn>scoring
			function</dfn>. If the function states that an exact match is +2 and a mismatch
		or gap insertion is a <dfn>penalty</dfn> of −1, then the score for 3
		matches and 5 mismatches/gaps is 3 × 2 + 5 × (−1) = 1.</p>
	<p>Thus a scoring function σ is defined such that σ(<i>x, y</i>) =
		scoring value, where <i>x</i> and <i>y</i> are characters or spaces/gaps. For
		the example, σ(<tt>c</tt>, <tt>c</tt>) = 2 and σ(<tt>c</tt>,
		<tt>a</tt>) = σ(<tt>c</tt>, −) = σ(−, <tt>c</tt>) =
		−1. And suppose that <i>S</i> represents the string (sequence of
		characters) and |<i>S</i>| is its length and <i>S</i>[<i>i</i>] is the
		<i>i</i>th character of <i>S</i>. Then if <i>S</i> is <tt>acbcdb</tt>,
		|<i>S</i>| = 6 and <i>S</i>[3] is <tt>b</tt>.
	</p>
	<p>
		If <i>S</i> and <i>T</i> are strings of characters, and an <dfn>alignmnet</dfn>
		<i>A</i> maps <i>S</i> and <i>T</i> into string <i>S′</i> and
		<i>T′</i> which may contain space characters (gaps) where
		|<i>S′</i>| = |<i>T′</i>| (that is, the aligned sequence of
		characters have equal length) and where removing the gaps from <i>S′</i>
		and <i>T′</i> produces <i>S</i> and <i>T</i>, respectively, then the value
		of the alignment <i>A</i> is computed:
	</p>

	<math xmlns="http://www.w3.org/1998/Math/MathML" style="font-size: 1em; 
font-family: serif;;margin-bottom:0;" display="block">
		<mstyle displaystyle="true" fontfamily="serif" mathcolor="blue">
			<mrow>
				<munderover>
					<mo>∑</mo>
					<mrow>
						<mi>i</mi>
						<mo>=</mo>
						<mn>1</mn>
					</mrow>
					<mi>l</mi>
				</munderover>
			</mrow>
			<mi>σ</mi>
			<mrow>
				<mo>(</mo>
				<mi>S</mi>
				<mo>'</mo>
				<mrow>
					<mo>[</mo>
					<mi>i</mi>
					<mo>]</mo>
				</mrow>
				<mo>,</mo>
				<mi>T</mi>
				<mo>'</mo>
				<mrow>
					<mo>[</mo>
					<mi>i</mi>
					<mo>]</mo>
				</mrow>
				<mo>)</mo>
			</mrow>
		</mstyle>
	</math>
	<p>
		where <i>l</i> = |<i>S′</i>| = |<i>T′</i>|. Note that lengths
		of <i>S′</i> and <i>T′</i> have already been computed because
		gapping/spacing is done before scoring can be done. An <dfn>optimal
			alignment</dfn> will be the particular alignment that produces the highest
		scoring value.</p>
	<p>
		The alignment of two strings is thus not being satisfied with what looks like
		the first plausible alignment, but using a computer to try and test many
		possible alignments and report the highest scoring. In sketching the algorithm,
		the pseudo-code looks something like this:</p>
	<pre> <b>for all</b> <i>i</i>, 0 ≤ <i>i</i> ≤ <i>n</i>, <b>do</b>
		<b>for all</b> subsequences <i>A</i> of <i>S</i> with |<i>A</i>} = <i>i</i> <b>do</b>
		<b>for all</b> subsequences of <i>B</i> of <i>T</i> with |<i>B</i>| = <i>i</i> <b>do</b>
		form the alignment that matches <i>A</i>[<i>k</i>] with <i>B</i>[<i>k</i>], 1 ≤ <i>k</i> ≤ <i>i</i>,
		and matches all other characters with spaces;
		score the alignment;
		keep alignment producing highest score;
		<b>end</b>;
		<b>end</b>;
		<b>end</b>;
	</pre>
	<p>
		If the string has a length n, then it will have
		<math xmlns="http://www.w3.org/1998/Math/MathML">
			<mstyle displaystyle="true" fontfamily="serif">
				<mrow>
					<mo>(</mo>
					<mtable>
						<mtr>
							<mtd>
								<mi>n</mi>
							</mtd>
						</mtr>
						<mtr>
							<mtd>
								<mi>i</mi>
							</mtd>
						</mtr>
					</mtable>
					<mo>)</mo>
				</mrow>
			</mstyle>
		</math>
		sequences of length <i>i</i>. If pairs (<i>A, B</i>) are to be aligned, then there
		are
		<math xmlns="http://www.w3.org/1998/Math/MathML">
			<mstyle displaystyle="true" fontfamily="serif">
				<msup>
					<mrow>
						<mo>(</mo>
						<mtable>
							<mtr>
								<mtd>
									<mi>n</mi>
								</mtd>
							</mtr>
							<mtr>
								<mtd>
									<mi>i</mi>
								</mtd>
							</mtr>
						</mtable>
						<mo>)</mo>
					</mrow>
					<mn>2</mn>
				</msup>
			</mstyle>
		</math> pairs to be aligned. Since |<i>S</i>| = <i>n</i>, and only
		<i>i</i> characters are matched to <i>T</i>, then <i>n − i</i> characters
		are unmatched. The final alignment will be <i>n</i> + (<i>n</i> −
		<i>i</i>) = 2<i>n − i</i>. The total number of operations to be
		done are:
	</p>
	<math xmlns="http://www.w3.org/1998/Math/MathML" style="font-size: 1em; 
font-family: serif;;margin-bottom:0;" display="block">
		<mrow>
			<munderover>
				<mo>∑</mo>
				<mrow>
					<mi>i</mi>
					<mo>=</mo>
					<mn>0</mn>
				</mrow>
				<mi>n</mi>
			</munderover>
		</mrow>
		<msup>
			<mrow>
				<mo>(</mo>
				<mtable>
					<mtr>
						<mtd>
							<mi>n</mi>
						</mtd>
					</mtr>
					<mtr>
						<mtd>
							<mi>i</mi>
						</mtd>
					</mtr>
				</mtable>
				<mo>)</mo>
			</mrow>
			<mn>2</mn>
		</msup>
		<mrow>
			<mo>(</mo>
			<mn>2</mn>
			<mi>n</mi>
			<mo>-</mo>
			<mi>i</mi>
			<mo>)</mo>
		</mrow>
		<mo>≥</mo>
		<mi>n</mi>
		<mrow>
			<munderover>
				<mo>∑</mo>
				<mrow>
					<mi>i</mi>
					<mo>=</mo>
					<mn>0</mn>
				</mrow>
				<mi>n</mi>
			</munderover>
		</mrow>
		<msup>
			<mrow>
				<mo>(</mo>
				<mtable>
					<mtr>
						<mtd>
							<mi>n</mi>
						</mtd>
					</mtr>
					<mtr>
						<mtd>
							<mi>i</mi>
						</mtd>
					</mtr>
				</mtable>
				<mo>)</mo>
			</mrow>
			<mn>2</mn>
		</msup>
		<mo>=</mo>
		<mi>n</mi>
		<mrow>
			<mo>(</mo>
			<mtable>
				<mtr>
					<mtd>
						<mn>2</mn>
						<mi>n</mi>
					</mtd>
				</mtr>
				<mtr>
					<mtd>
						<mi>n</mi>
					</mtd>
				</mtr>
			</mtable>
			<mo>)</mo>
		</mrow>
		<mo>&gt;</mo>
		<msup>
			<mn>2</mn>
			<mrow>
				<mn>2</mn>
				<mi>n</mi>
			</mrow>
		</msup>
		<mrow>
			<mtext>, for </mtext>
			<mspace width="1ex"></mspace>
		</mrow>
		<mi>n</mi>
		<mo>&gt;</mo>
		<mn>3</mn>
	</math>
	<p>
		The last inequality is determined using Stirling's approximation.
		When <i>n</i> = 20, then the algorithm means 2<sup>2<i>n</i></sup> = 2<sup>40</sup>
		or about 10<sup>12</sup> or 1 trillion operations. If an operation takes
		10 ns (nanoseconds) to complete, then the time required is
		10<sup>12</sup> operations × 10 × 10<sup>−9</sup> seconds /
		operation = 10<sup>4</sup> seconds, or 2 hours and 45 minutes.</p>
	<p>
		Suppose an algorithm that instead of 2<sup>2<i>n</i></sup> operations instead
		takes <i>n</i><sup>2</sup> operations. For <i>n</i> = 20, this means about 22
		times less time to compute the optimal alignment, or about 8 minutes instead of
		nearly 3 hours. If <i>f</i>(<i>n</i>) and <i>g</i>(<i>n</i>) are functions, it
		will true that <i>f</i>(<i>n</i>) = <i>O</i>(<i>g</i>(<i>n</i>)) if and only if
		a constant <i>c</i> is such that for a sufficiently large <i>n</i>,
		|<i>f</i>(<i>n</i>)| ≤ <i>c</i> × <i>g</i>(<i>n</i>). If function
		100<i>n</i><sup>2</sup> + 100<i>n</i> + 100 is <i>O</i>(<i>n</i><sup>2</sup>),
		then <i>c</i> = 101 will satisfy. If function 10,000<i>n</i><sup>2</sup> +
		100<i>n</i> + 100 is <i>O</i>(<i>n</i><sup>2</sup>), then <i>c</i> = 10,001 will
		satisfy.</p>
	<p>
		In computation of the optimal alignment, suppose string <i>S</i> and <i>T</i>
		are to be aligned and |<i>S</i>| = <i>n</i> and |<i>T</i>| = <i>m</i>. The
		value <i>V</i>(<i>i</i>, <i>j</i>) will be the score of the alignment of the
		comparisons of <i>S</i>[1] to <i>S</i>[<i>i</i>] and <i>T</i>[1] to
		<i>T</i>[<i>j</i>]. The optimal alignment value will be <i>V</i>(<i>n</i>,
		<i>m</i>) which results from computing <i>V</i>(<i>i, j</i>) with 0 ≤
		<i>i</i> ≤ <i>n</i> and 0 ≤ <i>j</i> ≤ <i>m</i> for larger values of
		<i>i</i> and <i>j</i>.
	</p>
	<p>
		The set of <q>basis</q> function for the start are i = 0 and j = 0:</p>
	<math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
		<mi>V</mi>
		<mrow>
			<mo>(</mo>
			<mi>i</mi>
			<mo>,</mo>
			<mn>0</mn>
			<mo>)</mo>
		</mrow>
		<mo>=</mo>
		<mrow>
			<munderover>
				<mo>∑</mo>
				<mrow>
					<mi>k</mi>
					<mo>=</mo>
					<mn>1</mn>
				</mrow>
				<mi>i</mi>
			</munderover>
		</mrow>
		<mi>σ</mi>
		<mrow>
			<mo>(</mo>
			<mi>S</mi>
			<mrow>
				<mo>[</mo>
				<mi>k</mi>
				<mo>]
				</mo>
			</mrow>
			<mo>,</mo>
			<mo>-</mo>
			<mo>)</mo>
		</mrow>
	</math>
	<math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
		<mi>V</mi>
		<mrow>
			<mo>(</mo>
			<mn>0</mn>
			<mo>,</mo>
			<mi>j</mi>
			<mo>)
			</mo>
		</mrow>
		<mo>=</mo>
		<mrow>
			<munderover>
				<mo>∑</mo>
				<mrow>
					<mi>k</mi>
					<mo>=</mo>
					<mn>1</mn>
				</mrow>
				<mi>j</mi>
			</munderover>
		</mrow>
		<mi>σ</mi>
		<mrow>
			<mo>(</mo>
			<mo>-</mo>
			<mo>,</mo>
			<mi>T</mi>
			<mrow>
				<mo>[</mo>
				<mi>k</mi>
				<mo>]</mo>
			</mrow>
			<mo>)</mo>
		</mrow>
	</math>
	<p>
		The expressions state that if <i>i</i> characters of <i>S</i> are aligned with 0
		characters of <i>T</i>, the match is with spaces, and for <i>V</i>(0, <i>j</i>),
		it is analogous.</p>
	<math xmlns="http://www.w3.org/1998/Math/MathML" style="margin-bottom:0;" display="block">
		<mi>V</mi>
		<mrow>
			<mo>(</mo>
			<mi>i</mi>
			<mo>,</mo>
			<mi>j</mi>
			<mo>)</mo>
		</mrow>
		<mo>=</mo>
		<mo>max</mo>
		<mrow>
			<mo>(</mo>
			<mi>V</mi>
			<mrow>
				<mo>(</mo>
				<mi>i</mi>
				<mo>-</mo>
				<mn>1</mn>
				<mo>,</mo>
				<mi>j</mi>
				<mo>-</mo>
				<mn>1</mn>
				<mo>)</mo>
			</mrow>
			<mo>+</mo>
			<mi>σ</mi>
			<mrow>
				<mo>(</mo>
				<mi>S</mi>
				<mrow>
					<mo>[</mo>
					<mi>i</mi>
					<mo>]</mo>
				</mrow>
				<mo>,</mo>
				<mi>T</mi>
				<mrow>
					<mo>[</mo>
					<mi>j</mi>
					<mo>]</mo>
				</mrow>
				<mo>)</mo>
			</mrow>
			<mo>,</mo>
		</mrow>
	</math>
	<math xmlns="http://www.w3.org/1998/Math/MathML" style="margin-left:3em;margin-top:0;margin-bottom:0;margin-left:3em;" display="block">
		<mi>V</mi>
		<mrow>
			<mo>(</mo>
			<mi>i</mi>
			<mo>-</mo>
			<mn>1</mn>
			<mo>,</mo>
			<mi>j</mi>
			<mo>)</mo>
		</mrow>
		<mo>+</mo>
		<mi>σ</mi>
		<mrow>
			<mo>(</mo>
			<mi>S</mi>
			<mrow>
				<mo>[</mo>
				<mi>i</mi>
				<mo>]</mo>
			</mrow>
			<mo>,</mo>
			<mo>-</mo>
			<mo>)</mo>
		</mrow>
		<mo>,</mo>
	</math>
	<math xmlns="http://www.w3.org/1998/Math/MathML" style="margin-left:3em;margin-top:0;margin-bottom:0;margin-left:3em;" display="block">
		<mi>V</mi>
		<mrow>
			<mo>(</mo>
			<mi>i</mi>
			<mo>,</mo>
			<mi>j</mi>
			<mo>-</mo>
			<mn>1</mn>
			<mo>)</mo>
		</mrow>
		<mo>+</mo>
		<mi>σ</mi>
		<mrow>
			<mo>(</mo>
			<mo>-</mo>
			<mo>,</mo>
			<mi>T</mi>
			<mrow>
				<mo>[</mo>
				<mi>j</mi>
				<mo>]</mo>
			</mrow>
			<mo>)</mo>
		</mrow>
		<mo>)</mo>
	</math>
	<p>
		The expression above says the optimal value will be the maximum of the set of
		three computed values, of which the first is the computed optimal alignment value
		of the first <i>i</i> − 1 of <i>S</i> and the first <i>j</i> − 1
		characters of <i>T</i> added to the score of pairing the <i>i</i>th character
		of S to the <i>j</i>th character of <i>T</i>. The second is the computed
		optimal alignment of the first <i>i</i> − 1 characters of <i>S</i> to
		<i>j</i> characters of <i>T</i>, adding in the score of comparing the <i>i</i>th
		character of <i>S</i> to a gap (space), which will penalize. The third
		is computation of the current optimal alignment value of the first <i>i</i>
		characters of <i>S</i> to the first <i>j</i> − 1 characters of <i>T</i>
		added to the penalty for comparing a space to the <i>j</i>th character of <i>T</i>.
	</p>
	<p>
		What this algorithm reveals is that shorter strings are at first optimally
		aligned and then characters or spaces one by one to compute a new score, and
		the highest of the possible scores is advanced choose the substring to be
		taken to the next step.</p>
	<table class="td-center scoring-matrix">
		<tbody>
			<tr>
				<th> </th>
				<th>j</th>
				<th>0</th>
				<th>1</th>
				<th>2</th>
				<th>3</th>
				<th>4</th>
				<th>5</th>
			</tr>
			<tr>
				<th>i</th>
				<th> </th>
				<th> </th>
				<th>c</th>
				<th>a</th>
				<th>d</th>
				<th>b</th>
				<th>d</th>
			</tr>
			<tr>
				<th>0</th>
				<th> </th>
				<td>0</td>
				<td>−1</td>
				<td>−2</td>
				<td>−3</td>
				<td>−4</td>
				<td>−5</td></tr>
			<tr>
				<th>1</th>
				<th>a</th>
				<td>−1</td>
				<td>−1</td>
				<td>1</td>
				<td>0</td>
				<td>−1</td>
				<td>−2</td></tr>
			<tr>
				<th>2</th>
				<th>c</th>
				<td>−2</td>
				<td>1</td>
				<td>0</td>
				<td>0</td>
				<td>−1</td>
				<td>−2</td></tr>
			<tr>
				<th>3</th>
				<th>b</th>
				<td>−3</td>
				<td>0</td>
				<td>0</td>
				<td>−1</td>
				<td>2</td>
				<td>1</td></tr>
			<tr>
				<th>4</th>
				<th>c</th>
				<td>−4</td>
				<td>−1</td>
				<td>−1</td>
				<td>−1</td>
				<td>1</td>
				<td>1</td></tr>
			<tr>
				<th>5</th>
				<th>d</th>
				<td>−5</td>
				<td>−2</td>
				<td>−2</td>
				<td>1</td>
				<td>0</td>
				<td>3</td></tr>
			<tr>
				<th>6</th>
				<th>b</th>
				<td>−6</td>
				<td>−3</td>
				<td>−3</td>
				<td>0</td>
				<td>3</td>
				<td>2</td></tr>
		</tbody>
	</table>
	<p>
		The table above shows how each scoring is done for each pairing of <i>S</i> =
		<tt>acbcdb</tt> and <i>T</i> = <tt>cadbd</tt>. Thus, the table entry for
		<i>i</i> = 4 and <i>j</i> = 1 was computed to be <code>max(−3 + 2,
			0 − 1, −4 − 1) = −1</code>. The final value will be for
		<i>i = m</i> and <i>j = n</i>, which is the last row and column in the table.
		This value is 2, which is higher than the initially done alignment which scored
		a final value of 1. To determine the sequence that actually gave the better
		alignment, start from the entry representing <i>i = m</i> and <i>j = n</i>
		and work backward to (0,0). Movements are either horizontal or vertical,
		introducing a space or gap, while diagonal movements mark a pairing/match.
		The decision regarding the movement is based on which three values represent
		the highest (max) of the set. If the values in a set are equal, the diagonal
		movement will prevail in any equal score as long as it is the maximum value.
	</p>
	<ol>
		<li>Going up (to <i>m</i> − 1) the score is 3. Also going left (to
			<i>n</i> − 1) the score is three. This means that the alignment can
			have <tt>b</tt> from string <i>S</i> or <tt>d</tt> from string <i>T</i> as
			the last position in the aligned string. Currently there are now two
			paths moving to (0, 0), and so two strings must be managed.
		</li>
		<li>For the <i>m</i> − 1 path, the entry (<i>m</i> − 2,
			<i>n</i> − 1) = 1, which allow for a pairing. From the <i>n</i> −
			1 path, the diagonal movement is the best, so there is another pairing.
		</li>
		<li>The entry at (<i>m</i> − 2, <i>n</i> − 1) must go to
			(<i>m</i> − 3, <i>n</i> − 1), which introduces a gap.
			The other path proceeds to a diagonal.</li>
		<li>Only one divergent path exists on one of the paths. This ends up
			producing three possible pairings with the maximum score.</li>
	</ol>
	<p>
		In the end, the three possible alignments are:</p>
	<pre>a c b c d b - a c b c d b - - a c b c d b
		- c - a d b d - c a - d b d c a d b - d -
	</pre>
	<p>
		All alignments give a final score of 2.</p>
	<p>
		The computation of an (<i>m</i> + 1)(<i>n</i> + 1) table has time complexity
		of <i>O</i>(<i>mn</i>). There are six table lookups, three additions, and
		compuation of three value maximum, which are constant in time, say <i>c</i>.
		Thus <i>O</i>(<i>mn</i>) = <i>c</i>(<i>m</i> + 1)(<i>n</i> + 1). Time for
		each reconstruction is <i>O</i>(<i>m</i> + <i>n</i>).</p>

	<h2>Pairwise Alignment</h2>
	<p>
		Resemblance of two DNA sequences can be explained that they derive from
		an ancestral sequence to which changes (mutations) occur: insertions,
		deletions, substitutions. Given two sequences, the <b>distance</b> between them
		is the minimal sum of weights for a set of mutations transforming one into
		the other. The <b>similarity</b> between them is the maximal sum of weights.
		Terms are defined here to relate biology to computation:</p>

	<table>
		<tbody>
			<tr>
				<th>Biology</th>
				<th>Computer Science</th>
			</tr>
			<tr>
				<td>sequence</td>
				<td>string, word</td></tr>
			<tr>
				<td>subsequence</td>
				<td>substring (contiguous)</td></tr>
			<tr>
				<td>n/a </td>
				<td>subsequence</td></tr>
			<tr>
				<td>n/a </td>
				<td>exact matching</td></tr>
			<tr>
				<td>alignment </td>
				<td>inexact matching</td></tr>
		</tbody>
	</table>

	<p>
		In computer science a subsequence is a non-contiguous segment of a sequence,
		but the usual reference is to the biological, in which it is a contiguous
		substring.</p>

	<h3>Edit Distance</h3>
	<p>
		The <b>edit distance</b> is the minimal number of edit operations to transform
		one sequence into another. This value can be used to roughly measure the
		count of DNA replications that occurred between the two DNA sequences.
		For sequences <tt>ACCTGA</tt> and <tt>AGCTA</tt>. Two edit operations
		transform one to the other:</p>


	<h2>Local Alignment</h2>
	<p>
		While it is useful to compute a maximum (optimum) value over an entire
		string, there are actually substrings of the complete string that have
		quite high scoring alignments but are not aligned because in the end they do
		match the <dfn>global</dfn> maximum. These <dfn>local</dfn> maximum of
		substrings however show a purposeful or useful pattern which indicates
		important biological structure of function. A starting algorithm may look so:</p>
	<pre> <b>for all</b> substrings <i>A</i> in <i>S</i>, <b>do</b>
		<b>for all</b> substrings <i>B</i> in <i>T</i> <b>do</b>
		Find optimal alignment of <i>A</i> and <i>B</i>
		Keep substrings <i>A</i> and <i>B</i> which have maximum alignment value
		and their alignments
		<b>end</b>;
		<b>end</b>;
		Output retained <i>A</i>, <i>B</i>, alignment, and score
	</pre>
	<p>
		Careful computation requires keeping track of certain properties. First
		is that a string (or substring) can be <dfn>empty</dfn>, so the empty string
		<i>e</i> is |<i>e</i>| = 0. Consider a string <i>U</i> which is a
		<dfn>prefix</dfn> of <i>S</i> if and only if <i>U = S</i>[1]...<i>S</i>[<i>k</i>] or
		<i>U = e</i>, where 1 ≤ <i>k</i> ≤ <i>n</i>. Consider also a string
		<i>U</i> which is a <dfn>suffix</dfn> of <i>S</i> if and only if <i>U</i> =
		<i>S</i>[<i>k</i>]...<i>S</i>[<i>n</i>] or <i>U = e</i>, and where
		|<i>S</i>| = <i>n</i> and 1 ≤ <i>k</i> ≤ <i>n</i>. If <i>S</i>
		is <tt>abcxdex</tt>, then the set of prefixes of <i>S</i> include <tt>ab</tt>,
		and of suffixes of <i>S</i> include <tt>xdex</tt>. The empty string <i>e</i>
		is both prefix and suffix.
	</p>
	<p>
		For <i>S</i> and <i>T</i> with |<i>S</i>| = <i>m</i> and |<i>T</i>| =
		<i>n</i>, for 0 ≤ <i>i</i> ≤ <i>m</i> and 0 ≤ <i>j</i> ≤ <i>n</i>,
		<i>v</i>(<i>i, j</i>) is the maximum value of an optimum alignment of
		α and β over all suffixes α of <i>S</i>[1]...<i>S</i>[<i>i</i>]
		and all suffixes of β of <i>T</i>[1]...<i>T</i>[<i>j</i>].
	</p>
	<p>
		If <i>S</i> is <tt>abcxdex</tt> and <i>T</i> is <tt>xxxcde</tt>, then
		<i>v</i>(5,5) = 3 for α of <tt>cxd</tt> and β of <tt>cd</tt> and
		the alignment is:
	</p>
	<pre> c x d
		c - d
		---------
		+2 -1 +2
	</pre>
	<p>
		A table is constructed is set up using a new basis and recurrence. Each entry
		would be an optimal pair (α, β) of suffixes of a given pair
		(<i>i,j</i>) of prefixes. As a suffix of a prefix is also a substring, the
		optimal pair of substrings is maximized with value <i>v</i>(<i>i,j</i>)
		over all possible prefix pairs (<i>i,j</i>).</p>
	<div style="text-align:left;">
		<math xmlns="http://www.w3.org/1998/Math/MathML" style="margin-left:-9em;margin-bottom:0;" display="block">
			<mi>v</mi>
			<mrow>
				<mo>(</mo>
				<mi>i</mi>
				<mo>,</mo>
				<mi>j</mi>
				<mo>)</mo>
			</mrow>
			<mo>=</mo>
			<mo>max</mo>
			<mrow>
				<mo>(</mo>
				<mn>0</mn>
				<mo>,</mo>
			</mrow>
		</math>
		<math xmlns="http://www.w3.org/1998/Math/MathML" style="margin-left:3em;margin-top:0;margin-bottom:0;" display="block">
			<mi>v</mi>
			<mrow>
				<mo>(</mo>
				<mi>i</mi>
				<mo>-</mo>
				<mn>1</mn>
				<mo>,</mo>
				<mi>j</mi>
				<mo>-</mo>
				<mn>1</mn>
				<mo>)</mo>
			</mrow>
			<mo>+</mo>
			<mi>σ</mi>
			<mrow>
				<mo>(</mo>
				<mi>S</mi>
				<mrow>
					<mo>[</mo>
					<mi>i</mi>
					<mo>]</mo>
				</mrow>
				<mo>,</mo>
				<mi>T</mi>
				<mrow>
					<mo>[</mo>
					<mi>j</mi>
					<mo>]</mo>
				</mrow>
				<mo>)</mo>
			</mrow>
			<mo>,</mo>
		</math>
		<math xmlns="http://www.w3.org/1998/Math/MathML" style="margin-left:3em;margin-top:0;margin-bottom:0;" display="block">
			<mi>v</mi>
			<mrow>
				<mo>(</mo>
				<mi>i</mi>
				<mo>-</mo>
				<mn>1</mn>
				<mo>,</mo>
				<mi>j</mi>
				<mo>)</mo>
			</mrow>
			<mo>+</mo>
			<mi>σ</mi>
			<mrow>
				<mo>(</mo>
				<mi>S</mi>
				<mrow>
					<mo>[</mo>
					<mi>i</mi>
					<mo>]</mo>
				</mrow>
				<mo>,</mo>
				<mo>-</mo>
				<mo>)</mo>
			</mrow>
			<mo>,</mo>
		</math>
		<math xmlns="http://www.w3.org/1998/Math/MathML" style="margin-left:3em;margin-top:0;margin-bottom:0;" display="block">
			<mi>v</mi>
			<mrow>
				<mo>(</mo>
				<mi>i</mi>
				<mo>,</mo>
				<mi>j</mi>
				<mo>-</mo>
				<mn>1</mn>
				<mo>)</mo>
			</mrow>
			<mo>+</mo>
			<mi>σ</mi>
			<mrow>
				<mo>(</mo>
				<mo>-</mo>
				<mo>,</mo>
				<mi>T</mi>
				<mrow>
					<mo>[</mo>
					<mi>j</mi>
					<mo>]</mo>
				</mrow>
				<mo>)</mo>
			</mrow>
			<mo>)</mo>
		</math>
	</div>
	<p>
		The formula looks similar except the first term evaluates to zero, which
		represents the value of alignment when α = <i>e</i> and β = <i>e</i>.
		When α ≠ <i>e</i> and β ≠ <i>e</i>, and the last matched
		pair in <i>A</i> is (<i>S</i>[<i>i</i>], <i>T</i>[<i>j</i>]), the remainder
		of <i>A</i> has the value <i>v</i>(<i>i</i> − 1, <i>j</i> − 1).
		When α ≠ <i>e</i> and last matched pair in <i>A</i> is
		(<i>S</i>[<i>i</i>], −) then remainder of <i>A</i> has value of
		<i>v</i>(<i>i</i> − 1, <i>j</i>). And when β ≠ <i>e</i> and
		the last matched pair in <i>A</i> is (−,<i>T</i>[<i>j</i>]) then
		remainder of <i>A</i> has value of <i>v</i>(<i>i, j</i> − 1).
	</p>
	<table class="td-center scoring-matrix">
		<tbody>
			<tr>
				<th> </th>
				<th>j</th>
				<th>0</th>
				<th>1</th>
				<th>2</th>
				<th>3</th>
				<th>4</th>
				<th>5</th>
				<th>6</th>
			</tr>
			<tr>
				<th>i</th>
				<th> </th>
				<th> </th>
				<th>x</th>
				<th>x</th>
				<th>x</th>
				<th>c</th>
				<th>d</th>
				<th>e</th>
			</tr>
			<tr>
				<th>0</th>
				<th> </th>
				<td>0</td>
				<td>0</td>
				<td>0</td>
				<td>0</td>
				<td>0</td>
				<td>0</td>
				<td>0</td></tr>
			<tr>
				<th>1</th>
				<th>a</th>
				<td>0</td>
				<td>0</td>
				<td>0</td>
				<td>0</td>
				<td>0</td>
				<td>0</td>
				<td>0</td></tr>
			<tr>
				<th>2</th>
				<th>b</th>
				<td>0</td>
				<td>0</td>
				<td>0</td>
				<td>0</td>
				<td>0</td>
				<td>0</td>
				<td>0</td></tr>
			<tr>
				<th>3</th>
				<th>c</th>
				<td>0</td>
				<td>0</td>
				<td>0</td>
				<td>0</td>
				<td>2</td>
				<td>1</td>
				<td>0</td></tr>
			<tr>
				<th>4</th>
				<th>x</th>
				<td>0</td>
				<td>2</td>
				<td>2</td>
				<td>2</td>
				<td>1</td>
				<td>1</td>
				<td>0</td></tr>
			<tr>
				<th>5</th>
				<th>d</th>
				<td>0</td>
				<td>1</td>
				<td>1</td>
				<td>1</td>
				<td>1</td>
				<td>3</td>
				<td>2</td></tr>
			<tr>
				<th>6</th>
				<th>e</th>
				<td>0</td>
				<td>0</td>
				<td>0</td>
				<td>0</td>
				<td>0</td>
				<td>2</td>
				<td>5</td></tr>
			<tr>
				<th>7</th>
				<th>x</th>
				<td>0</td>
				<td>2</td>
				<td>2</td>
				<td>2</td>
				<td>1</td>
				<td>1</td>
				<td>4</td></tr>
		</tbody>
	</table>
	<p>
		The backtrack of the table shows that two alignments are high scoring:</p>
	<pre> c x d e x - d e
		c - d e x c d e
	</pre>
	<p>
		Both alignments have three matches and a space, and the score is 3 × 2
		+ 1 × (−1) = 5. The time complexity is <i>O</i>(<i>m + n</i>),
		the same as for the previous alignment. The space required for the algorithm
		is related to the square of the length of the strings. It is possible to
		modify the algorithm to compute alignment in <i>O</i>(<i>m + n</i>) space and run
		in <i>O</i>(<i>mn</i>) time. Alignment reconstruction is done also in this
		space and time using divide and conquer, only slightly more complicated.</p>

	<h2>Gaps in Optimal Alignment</h2>
	<p>
		Insertions and deletions of long-length substrings are rare events in
		evolutions, but have equal probability to insertion or deletion of single
		characters. The cDNA of eukaryotic mRNA is sequence containing huge gaps when
		aligned to genomic DNA because of the biological role of introns. These two
		instances thus make it difficult to heavily penalize gaps based on count of
		characters in a gap; there is a strong motivation to align despite huge
		gaps.</p>
	<p>
		<b>Affine Gap Model</b>. Consider a function Wg + qWs where Wg is the
		penalty value for introducing a gap and Ws is the value of a penalty applied
		for gap length (a per-character gap penalty), and q is the length of the gap.
	</p>


	<ol>
		<li>substitute 'G': <tt>ACCTGA</tt> → <tt>AGCTGA</tt></li>
		<li>delete 'A': <tt>AGTGA</tt> → <tt>AGCT-A</tt> → <tt>AGCTA</tt></li>
	</ol>


	<h1>Named Alignment Methods, Tools, and Utilities</h1>
	<p>
		Methods that align sequences of proteins or nucleotides work in two categories:</p>
	<ol>
		<li><b>Pairwise/Multiple Alignment</b> <br>
Alignment of a set of a pair or more known sequences using criteria set
by the user, often for optimal alignment</li>
		<li><b>Sequence Search</b> <br>
The use of a single query sequence in order to search a database for result
sequences by user-specified alignment criteria.  The BLAST family of search
tools is the archetypal example.</li>
	</ol>


	<h2>Pairwise/Multiple Alignment Tools, Utilities, Methods</h2>

	<h3>Carrillo-Lipman Method for Optimal Multiple Alignment</h3>


	<h2>Sequence Search Tools, Utilities, Methods</h2>

	<h3>BLAST</h3>
	<p>
		The Basic Local Alignment Search Tool (BLAST) is one of the most rapid sequence
		similarity search applications. It comes in various forms, many of them
		specialized or improved</p>
	<p>
		NCBI-BLAST2 (National Center for Biotechnology Information BLAST version 2)
		offers its users six different alignment output options, adjustable gap-open and
		extension penalties, and choice of filtering programs. The user can set the
		first <i>n</i> number of hits in display that shows multiple sequence alignment.
		The EMVEC database (vector sequences) can be checked to search for vector
		contamination.</p>
	<p>
		WU-BLAST2 (Washington University BLAST version 2) is a nucleotide and protein
		sequence search that includes a <em>sensitivy</em> parameter, which at higher
		values makes the search more selective at the expense of prolonging it.
		Gap-open and extension penalties are adjusted according to matrix and
		sensitivity settings.</p>
	<p>
		In searching sequences, BLAST takes a usually shorter <i>query</i> sequence and
		uses it to search a larger <i>target</i> or <i>subject</i> sequence, or even a
		whole database of sequences. The query sequence can be filtered to mask
		low-complexity regions. Low complexity in polynucleotides and polypeptides
		refers to homopolymeric tracts, short-period repeats, or segments enriched in
		only a few residues. They score high in BLAST because of compositional bias
		rather than position-by-position alignment.</p>
	<p>
		BLAST comes with different forms of the application:</p>
	<ul>
		<li><b>BLASTP</b> takes a query of an amino acid string and searches
			a target/subject sequence of an amino acid string. It can be run with default
			or with the PSI-BLAST option, which uses search results to produce
			a profile for subsquent (interative) rounds of searching.</li>
		<li><b>BLASTN</b> takes a query of a nucleotide string <em>and</em> its
			complement, and uses the two in searching a target/subject nucleotide
			string. The search optimizes for speed, not sensitivity; do not use for
			finding distantly related coding sequences.</li>
		<li><b>BLASTX</b> takes the translation of a query nucleotide string in
			six reading frames, and searches one or more target/subject amino acid
			strings; useful in finding frameshift errors in sequence types like ESTs,
			HTGs, and single pass sequences.</li>
		<li><b>TBLASTN</b> takes a query sequence of an amino acid string and searches a
			target/subject sequence of a nucleotide string in six possible reading frames.
			Quite useful in search an EST database, or for finding undocumented open reading
			frames or frameshift errors in nucleotide sequnces</li>
		<li><b>TBLASTX</b> takes a query sequence of a nucleotide string translated in
			six possible reading frames, and searches target/subject sequence of a
			nucleotide string also translated in six possible reading frames. Use it only if
			BLASTN and BLASTX produce no results. Usually restricted to a search of subject
			sequences in EST, STS, HTGS, GSS, and Alu databases</li>
	</ul>
	<p>
		Query sequence filtering can be done using programs like DUST or SEG (see
		Woodson and Federhen 1993).</p>
	<p>
		<b>Results</b>. Results may be presented graphically, but will be given a
		<i>score</i> and <i>e(xpectation) value</i>. A factor used in scoring is
		the BLOSUM-62 matrix, in which comparison of a letter represents a substitution,
		and the effect of the substitution is assesed. If a nt substitution does
		not cause change at coding level (fully conserved), then a factor in the matrix
		reflects that. If a change is shows phyiscochemical conservation to some degree,
		that too is reflected. The <i>e value</i> reflects how many times one might
		see a position change by chance (a reflection of statistical significance);
		in most cases, significance would be an <i>E</i> &lt; 0.05. In most cases,
		maximum number of hits is about 500. <i>E values</i> are computed by size
		of database and the length of the query string: increases in either database
		size or of query length would increase the likelihood of purely chance matches.
		The statistics are calcualted according to Karlin and Altschul (1990, 1993).
		The raw score is computed using a table of residue substitution scores, and
		also penalties for the existence and the extension of any gap. For
		comparisons of amino acid strings, the residue substitution score table would
		give a positive value for L aligned with I, a negative score of L aligned
		with E. For nt-to-nt comparisons, it is simpler: positive score for matches,
		and negatives for mismatches. For gaps, a score is given for just the existence
		of a gap, and an additional penalty for the length, with a total gap
		score = −(<i>a</i> + <i>bk</i>), where <i>a</i> is gap existence
		penalty, <i>b</i> is the unit penalty for the gap, and <i>k</i> is the number
		of characters required to make the gap. These scores can be user-defined:
		affine gap costs.
	</p>
	<p>
		<b>Bit scores</b>. Bit scores are calculated from raw scores as follows:
	</p>
	<p class="eqnserif">
		<i>S</i><sub>bit</sub> = λ × <i>S</i><sub>raw</sub> − ln
		<i>K</i>&nbsp;/&nbsp;ln 2
	</p>
	<p>
		where λ and <i>K</i> are Karlin-Altschul parameters depending on scoring
		system. Bit scores are comparable between different types of BLAST searches
		(protein-to-protein, protein-to-nucleotide, etc). Bit scores however do not
		take into account database size, and so <i>E</i> values may be more
		meaningful.</p>
	<p>
		The BLAST algorithm works by making a list/table of substrings in the query
		sequence based on a <q>word size</q> and their positions are recorded.
		The database is scanned to find words in the list. If match is found between
		query and database, alignment is extended (without using gaps) until score
		drops below maximum by certain difference, at which point maximum score is used.
		The aligned region is local alignemnt. Only in BLASTN are exact matches extended
		and default word size is 11 bp. For protein-based search, a default word size
		of 3 residues is used</p>

	<p>
		In the pairwise alignment presentation, the score, the number of conservative
		(<q>positive</q>) substitutions, identical residues, and gap count are given.</p>

	<p>
		<b>Which Matrix?</b>. There are different matrices to use which depend
		on string length of the query sequence.
	</p>
	<table class="td-center">
		<tbody>
			<tr>
				<th>Query length <br>(amino acids) </th>
				<th>Matrix </th>
			</tr>
			<tr>
				<td>&lt;35 </td>
				<td>PAM-30 </td></tr>
			<tr>
				<td>35-50 </td>
				<td>PAM-70 </td></tr>
			<tr>
				<td>50-85 </td>
				<td>BLOSUM-80 </td></tr>
			<tr>
				<td>&gt;85 </td>
				<td>BLOSUM-62 </td></tr>
		</tbody>
	</table>

	<p>
		<b>Global and local alignments</b>. Global alignments give priority to
		alignment along whole length of string, while local alignments give
		priority to short substrings in the string. Local alignments are more
		successful in finding functional domains in proteins and exons in genomic
		sequences. The Smith and Waterman (1981) is a local alignment based
		algorithm. A problem is that they are slow and impractical for searching
		current databases.
	</p>
	<p>
		<b>Speed vs. sensitivity</b>. With searching databases a heuristic algorithm
		makes use of certain shortcuts to provide speed vs. sensitivity. Adjustments
		can be made to tip balance to greater sensitivity.
	</p>

	<h3>FASTA</h3>
	<p>
		A set of programs used for <em>sequence similarity searching</em>. It is an
		improvement upon BLAST for nucleotide searching since it uses a smaller
		<i>k</i>-tuple than the minimum seven required for BLAST. It is good at finding
		patterns in long sequence regions having low similarity (good for highly
		diverged sequences).
	</p>
	<p>
		FASTA can be done against specialized databases, such as the EMBL
		Whole Genome Shotgun (WGS).</p>

	<ul>
		<li>SNP FASTA searches HGVBASE (human genome variation database).</li>
		<li>FASTAF takes queries of degraded peptides and searches/compares
			to protein sequences.</li>
		<li>FASTS takes data from mass spectrometry experiments and searches
			protein sequences in entire databases.</li>
	</ul>

	<h3>MPsrch</h3>
	<p>
		Protein sequence comparison tool employing the Smith/Waterman algorithm.
		It is the most sensitive and reliable if trying to detect distantly
		related members. Its performance shows fewer false positives than
		other tools.</p>

	<h3>SCANPS</h3>
	<p>
		<b>SCAN P</b>rotein <b>S</b>equence using full Smith/Waterman style
		searching and can identify multiple domain matches with iterative profile
		searching, similar to PSI-BLAST.
	</p>

	<h1>Sequence Analysis</h1>
	<p>
		Sequence analysis involves pairwise and mulitiple sequence alignment as well
		as finding regions associated with coding and signaling, and checking the
		quality of open reading frames (ORFs).</p>
	<p>
		At EBI, the EMBOSS package contains a number of specific tools discussed
		below.</p>

	<h2>ClustalW</h2>
	<p>
		A general purpose multiple sequence alignment tool for both nucleotides and
		proteins. It provides results for inferring phylogenies.</p>

	<h2>Needle and Water</h2>
	<p>
		Needle will compare and align two nucleotide or protein sequences covering
		the length of both. Water find the best region of similarity between those
		two sequences.</p>

	<h2>Transeq</h2>
	<p>
		Transeq translates nucleotides to protein sequences, and provide all
		six reading frames.</p>

	<h2>Pepinfo, Pepwindow, Pepstats</h2>
	<p>
		Used to provide molecular weight, isoelectric point, charge, average residue
		weight, hydrophobicity, and other physicochemical proteins of a protein
		sequences</p>

	<h2>CpGPlot, CpGReport, Isochore</h2>
	<p>
		Specifically looks for and provides plots and report for CpG-rich region,
		and gives GC content of the sequence. CpG regions help in identifying
		housekeeping and widely expressed genes and promoters in the human genome.</p>

	<h2>GeneWise</h2>
	<p>
		Use this to compare a protein sequence or profile to a DNA sequence since
		it inspects for introns and frameshift errors.</p>

	<h2>PromoterWise</h2>
	<p>
		Will look at both strands, compensating for inversions and translocations,
		and thus able to identify promoter regions.</p>

	<h2>GeneMark</h2>
	<p>
		Inspects nucleotide sequences for possible presence of genes. Markov
		models of coding and non-coding regions known to exist are used in the
		check for coding potential.</p>

	<h1>Protein Structure Prediction</h1>
	<p>
		Because determination of protein structure from crystals using x-ray
		crystallography and in solution NMR is not always possible and sometimes
		questioned as to whether it is real, attempts are made to analyze sequence
		patterns and determine how they predict structure.</p>


	<h1>Protein Function Analysis</h1>
	<p>
		Some <q>secondary</q> databases—the primary being genome and protein
		sequence databases with little or no annotation—contain information
		about the function of proteins or protein domains or motifs which have
		been associated with sequences, and so sequence queries can extract
		this information. Hits from these databases can help to assign nucleotide
		or protein sequences to proteins belong to certain families.</p>

	<h2>Prosite</h2>

	<h2>Pfam</h2>

	<h2>PRINTS</h2>

	<h2>InterPro</h2>
	<p>
		At EBI, the query interface to InterPro is the tool InterProScan, whose
		input can be nucleotide or protein; if using DNA sequence, an option of
		15 translation tables and required minimum ORF size are presented. Users
		can select nine different applications to launch for the query action,
		having preconfigured cutoff thresholds for different databases (ProDom,
		PRINTS, PIR, Pfam, SMART, TIGRfams, Prosite profiles, Prosite, Superfamily).</p>

	<h2>CluSTr</h2>
	<p>
		A database that present UniProt Knowledgebase proteins in groups of related
		proteins, it has its own search tool.</p>

	<h2>GeneQuiz</h2>
	<p>
		Takes a protein sequence input and finds a biochemical function using
		variety of search and analysis methods and using protein and DNA databases.</p>

	<h2>Rapid Automatic Detection and Alignment of Repeats (RADAR)</h2>
	<p>
		RADAR has an automatic algorithm to segment a query into repeat sequences,
		identifying short compositional biases, gapped approximate repeats, and
		complex repeat architectures.</p>

	<h1>Bioinformatics On The Web</h1>
	<ul style="font:bold 110% 'Courier New',Courier,monospace;">
		<li><a href="http://www.bioinformatics.org/">Bioinformatics.Org</a></li>
	</ul>

	<h2>European Bioinformatics Institute (EBI)</h2>
	<p>
		EBI is providing free tools in bioinformatics through the web. Their toolboxes
		can be divided into five classes:</p>

	<ol>
		<li><b>Similarity searches</b>. Used to identify similarities between novel
			query sequences and database sequences whose structure and function have
			been elucidated
			<ul>
				<li>FASTA</li>
				<li>WU-BLAST2</li>
				<li>NCBI-BLAST2</li>
				<li>MPsrch</li>
				<li>SCANPS</li>
			</ul>
			(The last two searches are protein sequence only.)
			<br>
Databases searched include EMBL Nucleotide Sequence Database, IMGT/LIGM,
UNIPROT, IMGT/HLA, complete genomes and proteomes, patented sequences at
European Patent Office, USPTO, and Japanese PO, and the PDB structure database.
		</li>
		<li><b>Protein function analysis.</b> Access to Prosite, Pfam, PRINTS,
			InterPro. Other tools include CluSTr, GeneQuiz, RADAR.</li>
		<li><b>Sequence analysis</b>. ClustalW, Needle/Water, Transeq,
			Pepinfo, Pepwindow, Pepstats, CpGPlot, CpGReport, Isochore, GeneWise,
			PromoterWise, GeneMark</li>
		<li><b>Structural analysis.</b> More useful in finding protein function.
			MSDlite from Macromolecular Structure Database, DALI server to compare
			3D protein structure, MaxSprout fast database to findin protein backbone
			and side chain coordinates from alpha (C) traces.</li>
		<li><b>Miscellaneous or non-categorized tools</b>. Expression profiler
			for microarray clustering, QuickGO for gene ontology database, Readseq
			to change formats and letter cases, remove gaps, extract selected features.</li>
	</ol>
	<p>
		The Sequence Retrieval System (SRS) is the main interface with two functions:
		data retrieval and application server. It is also available as SRS3D which
		provides a 3D viewer for structural biologists from many specialized structural
		databases such as HSSP, FSSP, PSSH.</p>


	<h2>Services Requiring Paid Subscription</h2>
	<ul>
		<li><a href="http://www.usyd.edu.au/sydneybioinformatics/angis/biomanager.shtml">University
				of Sydney Bioinformatics <b>BioManager</b></a></li>
	</ul>

	<h1>Glossary</h1>

	<dl>
		<dt id="homology">homology</dt>
		<dd>sequences and the organisms in which they occur are descended from a common
			ancestor, with the implication that the similarities are shared ancestral
			characteristics [from Lesk]</dd>
		<dt id="lines">LINES</dt>
		<dd>Long Interspersed Nuclear ElementS; repetitive sequences about 7000 bp
			long, about 10<sup>5</sup> in number, from the non-coding fractions of
			eukaryotic genomes, as much as 30% of human chromosomal DNA, and &gt; 50% of
			higher plant genomes</dd>
		<dt id="similarity">similarity</dt>
		<dd>the observation or measurement of resemblance and difference, indepdent of
			the source of the resemblance [from Lesk]</dd>
		<dt id="sines">SINES</dt>
		<dd>Short Interspersed Nuclear ElementS; repetitive sequences about 70-500 bp
			long, about 10<sup>6</sup> in number, inserting randomly in the non-coding fractions of
			eukaryotic genomes, as much as 30% of human chromosomal DNA, and &gt; 50% of
			higher plant genomes; enter genome through reverse transcription of RNA;
			5′ region has high tRNA homology, AT-rich 3′ region, and
			central region is variable; very useful for doing phylogeny studies,
			namely determinations of common ancestry; de-insertion is unknown (as
			for transposons)</dd>

	</dl>

	<h1>Software Useful in Bioinformatics</h1>

	<h2>NCBI's Genomics Workbench</h2>
	<p>
		To interact with the huge databases at NCBI, especially the genomics databases
		(Genome, Genes, Nucleotide), NCBI provides a downloadable application called <a href="http://www.ncbi.nlm.nih.gov/projects/gbench/">Genomics Workbench</a> (<a href="http://www.ncbi.nlm.nih.gov/projects/gbench/download.html">download
			page</a>) that is not particularly intuitive, but it does help in organizing
		<b>workspaces</b> and <b>projects</b> within those workspaces. One needs to
		read a series of web documents at NCBI web site to learn how to use the
		interface, but once it is learned, it is simple to utilize the application. A
		quick reference to the use of the interface is given in the table below, but it
		is important to read the instructions before trying to use the software.
	</p>
	<div id="quick-ref">
		<h1>Genomics Workbench Quick Reference</h1>
		<h2>Application Start</h2>
		<p>
			All subwindows/panels can be moved out of application window to become own
			window, and can be docked in any position in application window</p>
		<p>Use mouse to pull on title bar of subwindow or a tab.</p>
		<div>
			<b>Panels</b>
			<ul>
				<li>Project Tree View: upper left panel</li>
				<li>Main Application Window: upper right panel</li>
				<li>Selection Inspector: lower right panel</li>
				<li>Event View: lower left panel tabbed</li>
				<li>Task View: lower left panel active tab</li>
			</ul>
		</div>

		<h2>Projects &amp; Workspaces</h2>
		<p><b>Workspaces</b> have a blue-colored book icon. They contain <b>projects</b>
			which have green-colored book icons. Projects are files containing data, and
			can be shared between workspaces. Both workspaces and projects can contain
			separate notes and descriptors</p>

		<h3>Accession Prefixes</h3>
		<ul>
			<li><b>NC_</b>: reference sequence chromosomes </li>
			<li><b>NT_</b>: reference sequence contigs </li>
			<li><b>NG_</b>: reference sequences with some level of non-automated curation </li>
			<li><b>NM_</b>: reference sequence mRNA transcripts </li>
			<li><b>NP_</b>: reference sequence proteins </li>
		</ul>

		<h2>Search View</h2>
		<p>
			<b>Search Tool: Search NCBI Public Databases</b><br>
Form to search databases (Nucleotide, etc) using name, accession number, etc.
		</p>

		<h2>Graphical View</h2>
		<ul>
			<li>green bar: genes</li>
			<li>blue bar: transcripts / mRNA</li>
			<li>red bar: coding regions / proteins</li>
			<li>blue tick marsk: variations found in dbSNP
				<br>selectable if zoom in
			</li>
			<li>beneath variations, blue bars are components to assembly sequence</li>
			<li>black bars beneath genes: STS</li>
			<li><b>Z</b> key: show zoom slider <br>
   hold left mouse and drag up and down for zoom in and out</li>
			<li><b>R</b> key: rectangular zoom <br>
    hold R key, left-click and drag over a region</li>
		</ul>
		<p><b>Customizations</b>. The view can be changed by a bottom tab with several
			icons. These icons include changes to <i>decorations</i> of the annotations of
			mRNA and coding features (circle and square anchors, arrow fletchings, and
			arrowheads); <i>spacing</i> with a compact option; the dropdown menu specifyhing
			what sort of <i>content</i> to display; changing of <i>track order</i> by
			clicking a title bar and dragging. The settings for the graphical view can be
			remembered using <b><i>themes</i></b>.</p>
		<p><b>Tool Use</b>. Select region of by clicking inside ruler above sequence
			and drag to make gray rectangle cover gene model and select
			<b><i>Tools→Run&nbsp;Tool</i></b> from main menu, and Run Tool dialog
			appears for NCBI BLAST service for aligning sequences. A sequence is chosen
			in one option. The perhaps a MegaBLAST to search mRNA sequences can be done,
			with a query of <b>biomol mrna[prop]</b> to ensure only molecules known to be
			mRNA sequences are used in search.
		</p>

		<h2>Alignment Data</h2>
		<ul>
			<li><b>HitFilter</b>: best choice for working with large alignments</li>
			<li><b>Alignment Manager</b>: best option for de-aligning with short, detailed
				alignments</li>
		</ul>
	</div> <!-- id=quick-ref -->

	<h1 id="literature">Literature</h1>
	<p>None of this information would be possible without the vast abundance of
		information out there provided by hardworking researchers and scientists.</p>
	<p id="baxevanis">
		A. D. Baxevanis, B. F. F. Ouellette, <span style="text-decoration:underline;">eds.</span>,
		<i>Bioinformatics: A Practical Guide to the Analysis of Genes and Proteins</i>, 2nd Ed.,
		(New York: Wiley Interscience), 2001.
		<a href="javascript:history.back();">Go Back</a>
	</p>

	<p id="lesk">
		A. M. Lesk, <i>Introduction to Bioinformatics</i>, (Oxford University Press: New York), 2002.
		<a href="javascript:history.back();">Go Back</a>
	</p>


</body>

</html>