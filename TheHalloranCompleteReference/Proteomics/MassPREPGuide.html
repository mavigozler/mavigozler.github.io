<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
   "http://www.w3.org/TR/html4/strict.dtd">
<html lang="en">
<head>
<title>Mass PREP Guide</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="./stdcss/std.css" rel="stylesheet">
<link href="file://c:./stdcss/std.css" rel="stylesheet">
<style>
 td, th {vertical-align:top;}
 .func-call {white-space:pre;font:normal 80% 'Courier New',Courier,monospace;}
 .sectionheader {background-color:#555;color:white;
   font:bold 90% Verdana,Tahoma,sans-serif;}
</style>
</head>

<body>
<p id="title">
Mass PREP Guide

<hr>
<!-- ============================================================= -->

<h1>Instrument Basics</h1>

<h2>Tip Numbering of Robotic Arm Pipettors</h2>
<p>
There are four pipettors on the robotic arm.  These are numbered 1-4,
with tip #1 being at the rear, and tip #4 at the front.

<h2>Syringe Numbering</h2>
<p>
There are four syringes on the back panel, numbered 1-4.  Syringe #1
is on the right (closest to peristaltic pump).

<h2>VariSpan Motor</h2>
<p>
The VariSpan motor is a special motor in the probe that spaces the
probe tips from one another.  The range is 9 to 20 mm.  This permits
simultaneous pipetting.
<p>
96-well plates have a spacing of 9 mm (4.5 mm between well centers,
and 9 mm between every other well center).
<p>
Cooled reagent holders have a varispan spacing of 18 mm.
<p>
If varispan spacing is defined as &lt; 9 mm, the probes only pipette
one at a time.

<h1>Deck Calibration</h1>
<p>
The Mass PREP has a standard (two-panel) and extended (four-panel) deck.
The deck must be calibrated on installation and regularly checked monthly.

<p>
Pipettor tip #1 or #4 are used in the calibration.

<ol>
<li>Find the metal pylons (cone-like deck fittings with an extension
from the cone tip) and place them at the following positions, depending
on whether you are using the standard or extended deck:
 <ul>
 <li><b>Standard deck</b>:  A7, G7, A18, G18
 <li><b>Extended deck</b>:  Select the <b>Left Extension</b> and
<b>Right Extension</b> from the calibration dialog box and place the pylons
according to the hole locations given
 </ul>
<li>From the WinPREP menu, choose the expanding menu command
 <b>Utilities&minus;&gt;Setup&minus;&gt;Four Tip Arm&minus;&gt;Calibrate...</b>
<li>For no prior existing calibration, select <b>One Point</b>.
<li>Set <b>Motor Power</b> to <b>Off</b>.
<li>Manually position tip #4 at the point of the pylon at the indicated
coordinate.
<li><b>Update&rarr;Calculate</b>
<li>Select <b>Standard Deck</b>
<li>Select <b>Arrow Keys Move Motors</b>
<li>Set coordinate A7 and then <b>Go To</b>
<li>Use arrows and the Page Up/Dn keys to position tip 4.
<li>Again Update and Calculate
<li>Repeat for G7 and A18.
<li>Calculate
<li>Check with the fourth coordinate G18 (should be very close)
<li>If expanded deck, use their coordinate
</ol>

<h1>Probe Assembly</h1>
<p>
<img src="MassPrepGuide/ProbeAssemblySchematic.gif"
 alt="MassPREP/MultiProbeII Probe schematic"
 style="float:left;margin:2em 2em 2em 0;">
The probe assembly is composed of several parts (see schematic at left).
<p>
The <b>Z-Rack</b> is moved by the Z-motor for vertical movement of probe.
<p>
The <b>Z-Guide Rod</b> is part of the tip removal mechanism:  the tip holder
is pulled upward and the Z-guide rod remains stationary.
<p>
The <b>Clamping Sleeve</b> clamps the Teflon tubing to VersaTip.
<p>
The <b>Tip Clamp</b> clamps the VersaTip to tip holder.  The clamp should
be removed when changing VersaTip.
<p>
The <b>Adjuster Screw</b> adjusts tension in ejector collar release spring.
Tightening the screw is necessary if the ejector collar dislodges on tip
ejection.
<p>
The <b>Ejector Collar</b> ejects the tips, and can be pulled off for cleaning.
<p>
The <b>VersaTip</b> enables the MassPREP to be used with or without
disposable tips.  If disposable tips are not used, the tip is the
<i>fixed</i> tip.  The internal volume of the VersaTip is 165 &micro;l.
It will secure 20 and 200 &micro;l.

<h2>Liquid Sensing</h2>
<p>
The fixed tip (VersaTip) can sense changes to its capacitance and sense
liquids.  The same is true if tips are conductive (black).

<h1>System Water</h1>
<p>
Water is obtained from a tank (with float switch sensor) by peristaltic
pump to a manifold.  From the manifold it can go directly to the tip
during flushing and washing actions.
<p>
It can also be pulled in from a syringe via a 3-way valve.  Between the
syringe and VersaTip is tubing with a volume of 3.5 ml.  The syringe
is used in the aspiration and dispensing of all solutions and reagents
and water.
<p>
The water reservoir should never be allowed to fall below one quarter full.

<h2>Flushing System Liquid</h2>
<p>
All methods should implement a system flush to ensure no air bubbles are
in the tubing.
<p>
Before commanding the system to flush water through, first make sure that
the labware is configured properly.  This requires a wash well station
at a particular coordinate.  The file <b>FlushSysLiq.mpt</b> will show
a map of where the labware is expected.
<p>
There are two ways to command the system to flush water through the system.
<ol>
<li>
The command <b>File&rarr;Open...</b> can be used to find a method file
named <b>FlushSysLiq.mpt</b> which will perform the operation.  Open
the file, which shows the position of the labware on the deck map as well.
Then issue the Run command for the method.
<li>The menu command <b>Utilities&rarr;Diagnostic Tests&rarr;Flush and Wash Tips</b>
is dedicated for this purpose.
</ol>
<p>
The <b>Flush Volume</b> and <b>Wash Volume</b> settings should be
3000 &micro;l (3 ml).  Note that a <i>flush</i> is the system passing water
through the probe tubing only and ejecting it in the waste reservoir.
A <i>wash</i> is the probe moving over to the washing well and splashing
the system water around the probe tips to wash the outside of the tips.
<p>
The flushing is done using the syringes.  The washing is done using the
peristaltic pump.

<h1>Programming WinPREP (MassPREP)</h1>
<p>
Methods are created by adding labware to the deck map and then defining
procedures for their use.
<p>
When programming the method and adding labware to the method, the deck is
best viewed at a magnification of 25%.

<h2>Adding Labware</h2>
<p>
Click the right mouse button on the deck map to see a popup menu that
includes the command <b>Add Labware...</b>.  A dialog window appears that
allows selection of the labware.  Select the labware to add, and then
click the button <b>Add to deck</b>.  The mouse can be moved on the deck
map with an outline of the labware boundaries shown.  Press the button
to fix the location of the labware.
<p>
<b>Overlapping Labware</b>.  Press the <b>Alt</b> key and click left
mouse button to position one piece of labware to overlap with another.
This is done when putting labware on support tiles (see below).
<p>
<b>Support Tiles</b>.  Some labware sits on top of other labware (and is
required).  If a <i>support tile</i> is required to be underneath
a particular type of labware, it is indicated.

<h3>Used Tip Container</h3>
<p>
Used tips are put into a 500 ml plastic beaker.  Any container will do,
so long as it is not more than 12 cm high (the probe travel path height).

<h3>Wash &amp; Flush Station (Washbowl)</h3>
<p>
The system liquid flush method (and menu command) are mapped to a wash
station.  Make sure the waste tubing is connected to a waste container.

<h3>Reagent Troughs</h3>
<p>
There are 3 kinds of reagent containers.
<p>
The smallest one holds a maximum of 30 ml, and the volume to the collar
is 23 ml.
<p>
The middle one holds a maximum of 57 ml and the volume to the collar is
48 ml.
<p>
The largest one holds a maximum of 145 ml, and the volume to the collar is
114 ml.

<h2>Defining (Calibrating) Labware</h2>
<p>
For most common kinds of labware, the definitions and calibrations are
already included with the software.  However, users can and may need to
define labware that is not defined or will not work with alternative
definitions.  Sometimes the manufacturer will provide labware defintions
if they know their product is used in the MultiProbe II/WinPREP/MassPREP
system, and the user can enter the values directly.
<p>
To define/calibrate labware, double click on the labware on the deck map
after creating its class or type.  A <b>Parameters</b> dialog window
is opened.
<p>
In the dialog window, an overview is presented that shows
the name, type, file containing the
parameters/dimensions, and whether there is a support tile are defined.
The current location of the labware is shown as well.
<p>
Click the <b>Edit</b> button and a <b>Prepare for labware evaluation</b>
dialog opens.  Click <b>OK</b> button to get to the <b>Properties</b>
dialog window.
<p>
Two tabs appear:
<ol>
<li><b>Detail</b><br>
These show dimensions in millimeters of the labware.  Values can be
entered or changed here.
<li><b>Evaluate</b><br>
Use this to allow manual movement of the probe tip to a particular point
(make sure the deck is calibrated first!!!).  The physical dimensions
will be entered automatically for certain properties.  To move the probe
tip, either use the arrow keys/Pg Up/Pg Dn keys, or turn <b>Motor Power</b>
to <b>Off</b> and move by hand.
</ol>

<p>
Dimension in evaluate tab are X = left-to-right, Y = back-to-front,
V = varispan spacing, Z = down-to-up.
<p>
<b>Go To</b> is a button that will move the probe tip to the indicated
position.  If <b>First Well, First Column</b> is selected, then Go To
moves probe tip to well A1.  In setting the <b>Dispense Height</b>,
Go To moves tip to dispense height.
<p>
<b>Setting Well Bottom</b>.  Turn Motor Power off, position probe over
well, then push/pull tip down until it touches the well bottom.
If necessary, turn motor power back on, and use arrow and PgUp/PgDn
keys to move tip as well.  Select <b>Well Bottom</b> and then press
<b>Update</b> button.

<h4>X-Y Calibration</h4>
<p>
Well positions in labware with wells is defined by two paramters:
<ol>
<li>the position of well A1 (first row, first column)
<li>the well spacing:  9 mm for 96 well microplates, and 4.5 mm for
96 well MALDI target plates.  <b>Well Spacing</b> is in the Details
tab.
</ol>
<p>
<b>Calibrating Off Center</b>.  Generally the probe tip is positioned
in a well (such as a V-bottom well) to be offset from the center
(about &frac14; from the edge on one side, &frac34; from the other edge).

<h3>Labware Properties</h3>
<p>
Generally the properties for labware are as follows:

<ul>
<li><b>Multiwell (96-well) plates</b><br>
 <ul>
 <li><b>First Well, First Column</b>
 <li><b>Last Well, Last Column</b>
 <li><b>Well Spacing</b> (9 mm for 96 wells)
 <li><b>Well Bottom</b>
 </ul>
<li><b>Disposable Tips</b><br>
 <ul>
 <li><b>First Well, First Column</b> of the tip rack
 <li><b>Last Well, Last Column</b> of the tip rack
 <li><b>Well Spacing</b> (9 mm for typical tip racks)
 <li><b>Tip Length</b>:  highly variable, with 39.5 mm for 200 &micro;l
   black tips, 40 mm for 200 &micro;l clear tips, and
 	18 mm for 20 &micro;l black conductive tips
	(add 0.8 mm for Nunc microplates)
 </ul>
</ul>
<p>
Tips should touch the bottom of the well and slide about 1 mm towards the
center from their offset.  If tips do not touch, decrease tip length by
about 0.3 mm then check movement.  If the hit the well hard, increase
the tip length and try again.
<p>
For peptide solutions aspirate height is set to 0% in all transfer steps.
Peptide transfer is unreliable if probe does not reach well bottom.
The <b>Liquid Transfer Test</b> is designed to look at the reproducibility
of liquid transfer:  it dispenses 30 &micro;l to each well of a gel pieces
plate, then transfers that to a PCR plate.

<h3>Target Plates</h3>
<p>
Target plates have 96 wells with 24 lockmass wells.  The
parameters are <b>First Well, First Column</b> and <b>Well Bottom</b>,
one for the wells and the other for the lockmass wells (spots).  Well
spacing is automatically 4.5 mm.  Note that it is unlikely that all four
probes will align perfectly:  one must compromise on alignment to get
all four probes to spot within the well moat.
<p>
The lockmass wells are spotted only with probe 4, so calibrate probe 4
to go to center.
<p>
The <b>Well Bottom</b> is the target surface.  Use the keys and/or
turn motor power off to position the tip properly.  The tip must touch
the surface of the target.

<h3>Tip Height Parameters</h3>
<p>
There are 5 different parameters to specify with tip height, from
highest to lowest:
<dl>
<dt>Safe Travel Height
 <dd>The minimum height allowing the probe tip to move between wells
or labware.
<dt>Search Height
 <dd>At this height, the liquid level sensing (LLS) becomes active.
Set this higher than the maximum level at which the container can be filled.
<dt>Top of Well
 <dd>Set this parameter to the height at the top of the well.  Along with
 the <b>Bottom of Well</b> height setting, this permits calculations
 with respect to <b>% of Well Height</b>.
<dt>Dispense Height
 <dd>This is the height at which the probe stops to dispense fluid
<dt>Aspirate Height
 <dd>This is the height at which probe will aspirate liquid, normally
 set close to the bottom of the well.  Not always used since a procedure
 may set the aspirate height in a customized fashion.
</dl>

<h1>Pipetting</h1>
<p>
Pipetting in the system is done in one of two modes:
<ol>
<li><b>Waste</b><br>
 The solution is aspirated in a greater volume than will be dispensed.
 This mode is appropriate when pipetting a single reagent in which a single
 large aspirate is taken and multiple volumes are dispensed in the single
 aspirate.  If using fixed tips, set the waste volume to be ~25% of the
 aspirate volume.  For disposable tips, set the waste volume to be 10%
 of the aspirate volume.
<li><b>Blowout</b><br>
 The volume of the aspirate will be equal to the volume dispensed.
 This mode is appropriate for single dispensing.  In this mode, a
 blowout volume of air is aspirated before aspirating the solution
 (an air gap composed of system + blowout air gap is created).
</ol>
<p>
<b>Dispense Back</b> is an option for aspiration:  this is a volume that
is aspirated added to the normal aspirate volume, and which is dispensed
from the dispense height back into the same solution.

<h2>Air Gaps</h2>
<p>
Air gaps are created to separate reagents and solutions from the system
fluid (water).  This prevents dilution of the aspirated solution.
<p>
The <i>system air gap</i> is the air gap between the system water and
aspirate.  A gap of 10 &micro;l for the fixed tips, and 5 &micro;l when
using disposable tips is recommended.
<p>
The <i>transport air gap</i> is a gap created at the end of aspiration
to prevent dripping from the tip (and loss of volume).  Note that if
dripping is noticed there might be a leak or excessive air in tubing.
Transport air gaps are probably required when pipetting volatile solvents
(acetonitrile);  a gap of 5 &micro;l might be necessary.  A transport
air gap may not be necessary if waste mode is set.

<h1>Utility Methods</h1>
<p>
<b>FlushSysLiq.mpt</b> does a pump flush, then syringe flush, then
a pump wash.  It removes air bubbles from the lines.
<p>
<b>PickupTip Test 20 ul MBP.mpt</b> will pick up and drop the 20 &micro;l
MBP tips.  Do all 96 tips to verify and check for errors.
<p>
<b>PickupTip Test 200 ul MBP.mpt</b> will pick up and drop the 200 &micro;l
MBP tips.  Do all 96 tips to verify and check for errors.
<p>
<b>Lid Pickup Test.mpt</b> will (1) lift lid on PCR plate on cooled
support tile, (2) move it to microplate on heated tile, (3) then to the
lid support tile, (4) repeat these moves, and (5) return the lid to its
original position.
<p>
<b>Box Refill.mpt</b> will move tips from the right side of the box to
empty positions on the left side.  Specify the first and last positions
and the tips are moved.
<p>
<b>Aspirate from well bottom.mpt</b> puts 50 &micro;l of system liquid in
each well, then empties using 200 &micro;l tips.  Used to set correct
tip length.

<p>
<b>AlignTips On Target.mpt</b> is used to check for calibrating and aligning
tips on MALDI target surface.
<p>
<b>Align Tips on 4 Targets.mpt</b> is used for calibrating and aligning on
more than one MALDI target.

<h1 style="clear:left;">In-Gel Digestion with or without MALDI Plate Spotting</h1>
<p>
This uses Micromass' Digestion 5.7 MPT.  The option of spotting is
selected during the intial user queries.

<p>
Reagents for use in this method are prepared in polypropylene plastic
containers place on the deck.  There are three sizes of plastic container.
The table shows the volumes held by the containers and the amount up to
the plastic collars around them:

<table>
<caption>Plastic Reagent Containers Used in MassPREP</caption>
<tr><th>Size <th>Maximum Volume (ml) <th>Volume (ml) Up to Collar on Container
<tr><td>Largest <td>145 <td>114
<tr><td>2nd Largest  <td>57 <td>48
<tr><td>Smallest <td>30 <td>23
</table>
<p>
If the gel pieces in the multi-well (96- or 384-well) plates have dried
out, you should rehydrate them at least 3-4 hours before starting the
procedure.  For small gel pieces, add 25-50 &micro;l ultrapure water,
For larger, add 50-100 &micro;l.  With experience, you will add the
correct amount.  If you add too much, select the option to remove
excess liquid from the well prior to any important steps (de-staining,
reduction/alkylation).

<ol>
<li>Raise the hood glass sash and always keep the bottom of it above
the robotic arm whenever the robotic arm is moving.
<li>Turn on the power switch to the MassPREP.  It is located on the
upper left hand side of the vertical body.
<li>Turn on the PC that contains the WinPREP MultiPROBE II software.
<li>Check the <a href="#deckcal">deck calibration.</a>
<li>If you will use the cooling plates (most likely), turn on
the refrigerated water bath circulator.  Its setting will
be anywhere from 4-12&deg;.
<li>There are two sets of reagent troughs and plastic containers.
One set has been assigned for use with silver-stained gels, and the
other has been assigned for use with Coomassie-stained gels.
You may be using one or both of them.  Select the appropriate
set and determine the number of samples you have.  Then prepare the
following solutions:
 <ul>
 <li><b>Buffer</b>:  100 mM ammonium bicarbonate (NH<sub>4</sub>HCO<sub>3</sub>)
 <br>Pour 0.1 M (100 mM) ammonium bicarbonate into the reagent
container <b>Buffer</b> on the reagent containers labware.  To make
100 ml of it, weigh out 0.79 g ammonium bicarbonate and store in glass.
Use only the container marked &ldquo;Mass PREP Use Only&rdquo;!
Alternatively, you might want to make a stock 0.5 M ammonium bicarbonate,
since several reagents are prepared in 0.1 M (100 mM)
NH<sub>4</sub>HCO<sub>3</sub> and it is easier to make a dilution from
stock.
 <li><b>De-Stain</b>.  The contents of this container depend on what
type of stain has been done:
  <ul>
  <li><b>Silver De-Staining</b>:  15 mM potassium ferricyanide plus
50 mM sodium thiosulfate<br> Prepare 2&times; (30 mM) or 5&times;
(75 mM) potassium ferricyanide (K<sub>3</sub>Fe(CN)<sub>6</sub>)
stock in ultrapure water in a glass container.  Prepare 2&times; (100 mM)
or 5&times; (250 mM) sodium thiosulfate
(either anhydrous Na<sub>2</sub>S<sub>2</sub>O<sub>3</sub> or
its pentahydrate Na<sub>2</sub>S<sub>2</sub>O<sub>3</sub> &bull; 5
 H<sub>2</sub>O) in ultrapure water in a glass container.   From this
prepare the appropriate dilution:  if using 5&times;, use 1 part
of the K<sub>3</sub>Fe(CN)<sub>6</sub> stock, 1 part of the
Na<sub>2</sub>S<sub>2</sub>O<sub>3</sub> stock, and 3 parts ultra pure
water.  If using 2&times; stocks, mix each stock solution 1:1 (1 part
each).
  <li><b>Coomassie De-Staining</b>:
  </ul>
 <li><b>Reduction</b>:  10 mM DTT in 100 mM NH<sub>4</sub>HCO<sub>3</sub>.
Volume required at a minimum is 50 &micro;l per sample.  Micromass
recommends 10 ml (double that necessary) for one 96-well plate.
They recommend making it fresh each time, but it can be frozen for a few
months probably.
 <li><b>Alkylation</b>:  55 mM iodoacetamide in 100 mM NH<sub>4</sub>HCO<sub>3</sub>.
Volume required is 50 &micro;l per sample, and again Micromass recommends
using 10 ml for one 96-well plate.  Iodoacetamide is considered to
be rather reactive (even water can cause its substitution) and should
be made fresh.
 <li><b>Extraction</b>: 1% formic acid in 2% acetonitrile.<br>
 To make 10 ml (enough for one 96-well plate), prepare 100 &micro;l
 formic acid and 200 &micro;l MeCN in 10 ml water.
 <li><b>Trypsin in acetic acid</b>:  100 ng/&micro;l of sequencing-grade
trypsin in 50 mM acetic acid<br>
If the trypsin comes in 20 &micro;g vials, add 200 &micro;l of the
resuspension buffer (50 mM acetic acid) to get 100 ng/&micro;l.
For 48 samples, pipet 23 &micro;l to the glass reagent vial and
place in the cold reagent tray.  For 96 samples, place 45 &micro;l.
For 192 samples, place 90 &micro;l.
 </ul>
<li>Peform a system flush/wash and make sure the system tubing is primed
and no air bubbles are present.
<li>Make sure you have enough tips.  Do a tip pickup test and tip
re-loading (click <b>Reset Tip Boxes</b>) at the start of the program.
</ol>
<p>
Do not forget to put used items in freezer and refrigerator.
Unused trypsin is stored in its vial at &minus;20&deg;.  Store the DTT
stock in the freezer.  Put concentrated ammonium bicarbonate,
and any solid iodoacetamide

<h1>WinPREP File Types</h1>

<dl>
<dt>.MPT
 <dd>Method file, containing all procedures and the deck layout.
It is usually best to make method files from existing method files
(<b>File&rarr;Save As...</b>).

<dt>.PRF
 <dd>Performance file: contains all data regarding physical properties
controlling pipetting, such as the speed of aspiration and dispensing.

<dt>.PAT
 <dd>Pattern file:  used to generate well number sequence for sample plate.
This is necessary only when a new plate is mapped to a method

<dt>.RAK
 <dd>Labware definition file:  contains all data related with physical
properties (dimensions) of labware, include the count, size, and position
of wells.  The <i>xyz</i> coordinate system is used:  <i>x</i> is
left-to-right space, <i>y</i> is back-to-front space, <i>z</i> is
down-to-up space, in that order (low-to-high values).

<dt>.DAT
 <dd>There is one DAT file, <b>machine.dat</b>, that defines properties
of the system (standard or expanded), as well as the speed of the
motors that move the arm in the <i>xyz</i> directions, and also the
calibration of the deck.
</dl>

<h1>MultiProbe II Scripting Language (MSL)</h1>
<p>
The Perkin-Elmer MultiPROBE II instrument is controlled and programmable
through a script language known as MSL.  The description of it below
is taken from document files that come with the software.  There seems
to be no single compilation or reference for MSL through Perkin-Elmer
or the developers at Packard.

<h2>Elements</h2>
<p>
The MSL application uses a C interpreter originally known as CEL (C
Extension Language).  CEL is not ANSI standard C, and it is not C++.
<p>
The other Msl*.txt files in the samples directory enumerate the
available built in functions for serial and file I/O, use of timers,
user interface tools and C runtime library functions.
<p>
See the file MSLEXT.TXT in the bin directory for instructions on how
to add your own DLL functions to MSL.
<p>
Before adding your own script based functions to a WinPREP test, you
should review the following.  In spite of CEL's limitations, it is possible
to do substantial work from a script.

<table>
<tr><th>Avoid These Keywords! <th>Comments
<tr><td>enum        <td> Not supported.
<tr><td>extern      <td> Not supported.
<tr><td>float       <td> Use double instead.
<tr><td>do...while()<td> Not working (use while() instead)
<tr><td>void        <td> Not working (functions should return int instead of void)
<tr><td>static      <td> Not supported.
<tr><td>any #...    <td>Not supported (i.e. #include, #define, #if, etc.) See note
                7 below.
</table>


<table>
<tr><th>Misc Keyword Notes
     <th>Comments
<tr><td>
for     <td>    Cannot use comma operator e.g. for (a = 0 , i = 0;...);
                a "forever" loop cannot be constructed using 
                for (;;) - conditional part of "for" assumed
                to be present although flagging isn't done if it isn't
<tr><td>
goto   <td>    Generally ok but unreliable within loop statements
                (e.g. may exit loop prematurely or cause additional iteration)
<tr><td>
unsigned  <td>  unsigned short , unsigned -ok
                unsigned char behaves as if it is an unsigned int;
                unsigned long acts like unsigned short also in incremental
                expressions not for direct assignments.
<tr><td>
+=      <td>    Works fine when both sides have same data type <tr><td>
-=      <td>    Works fine when both sides have same data type <tr><td>
*=      <td>    Works fine when both sides have same data type <tr><td>
/=      <td>    Works fine when both sides have same data type <tr><td>
%=      <td>    Works fine when both sides have same data type <tr><td>
>>=     <td>    Works fine when both sides have same data type <tr><td>
<<=     <td>    Works fine when both sides have same data type <tr><td>
&amp;=      <td>    Works fine when both sides have same data type <tr><td>
|=      <td>    Works fine when both sides have same data type <tr><td>
^=      <td>    Works fine when both sides have same data type <tr><td>
																					<tr><td>
&amp;       <td>    Ok - pointers to pointers not handled completely
                     e.g double *dptr; <br>
                         double **dpptr;	 <br>
                         dpptr = &amp;dptr; <br>
                     gives "Pointer type mismatch for assignment 
                     operator." even though it is reasonable
<tr><td>
constants <td>  Hex (0x) and octal(prefacing 0) constant notation ok.
                Character constants in octal and hex DO NOT work
                (e.g. '\0101'). Note character constant initialization
                ( e.g. char a = '*';) works ok
<tr><td>
conditional ?:<td> Ok.  But the condition expression needs to be put into a
                pair of parentheses.
</table>


<h3>Additional Notes</h3>

<ol>
<li>Does NOT handle bracket notation "[]" as an alias of "*"
    e.g. "char arr_a[]" is NOT supported,  but "char *arr_a" is

<li>A maximum of 144 bytes of information may be passed to a script function.
   This means 18 doubles, 36 pointer,longs,floats, or 72 integers,characters.
   Of course you can mix variable types as long as the total number of
   bytes that are passed to a function are less than 144.

<li>Does not handle '\0' as a character (assumes its octal)--use 0 instead.
   For example:
        x[3]='\0';  // does not work
        x[3]=0;     // this is OK

<li>Does not always handle typedef w/in another typedef.


<li>Do not include script based typedefs in the argument list of a script
   function.  Instead, pass structure pointers as char*, then load the
   char* into a structure pointer.  e.g.

<code>
   int Uf_MyProc(     // 0=Normal; 3=Abort
       char*  pPCX )  // Address of procedure context information
   {
        int nRet = 0;                       // Load return value into nRet
        MP2_PROC_CONTEXT_DEF* pPC = pPCX;   // Cast pPCX into local procedure context ptr

        ...

        return nRet;
   }
</code>

This is not a limitation for built in MSL functions or DLL functions.

  
<li>The return value of a script function should be int or double.  Do not
   attempt to return a pointer as the value of a function.
   However, built in MSL functions and DLL functions may return pointers.

<li>Multiple script files may be combined into a single script by using a
   project file (.PRO).  When the WinPREP application constructs a script,
   it places the names of all the individual script files in a project
   file and passes that project file to MSL.
</ol>

<h2>C Runtime Library Function</h2>
<p>
The following C runtime library functions are callable from MSL script.
To use them you should consult your own developer's documentation.
<table>
<tr><td>	asctime	<td>	floor	<td>	memcpy	<td>	strchr
<tr><td>	atof	<td>	fputs	<td>	memset	<td>	strcmp
<tr><td>	atoi	<td>	fopen	<td>	mktime	<td>	strcpy
<tr><td>	atol	<td>	fflush	<td>	pow	<td>	stricmp
<tr><td>	calloc	<td>	fprintf	<td>	printf	<td>	strlen
<tr><td>	ceil	<td>	fread	<td>	rand	<td>	strlwr
<tr><td>	clock	<td>	free	<td>	realloc	<td>	strncmp
<tr><td>	cos	<td>	fscanf	<td>	RemoveDirectory	<td>	strncpy
<tr><td>	CreateDirectory	<td>	fseek	<td>	scanf	<td>	strstr
<tr><td>	CreateDirectoryEx	<td>	fwrite	<td>	SetFileAttributes	<td>	strtok
<tr><td>	ctime	<td>	_flushall	<td>	sin	<td>	strupr
<tr><td>	DeleteFile	<td>	_fileno	<td>	Sleep	<td>	system
<tr><td>	difftime	<td>	_fstat	<td>	sprintf	<td>	tan
<tr><td>	exit	<td>	GetFileAttributes	<td>	sqrt	<td>	time
<tr><td>	exp	<td>	localtime	<td>	srand	<td>	unlink
<tr><td>	fabs	<td>	log	<td>	sscanf	<td>
<tr><td>	fclose	<td>	log10	<td>	stat	<td>
<tr><td>	fgets	<td>	malloc	<td>	strcat	<td>
</table>

<h2>Instrument Library Functions</h2>

<table style="margin-left:-10%;font-size:83%;">
<col span="3" style="width:8em;">
<col style="width:15em;">
<thead>
<tr><th>Function <th>Purpose  <th> Notes     <th>Method
<tbody style="height:35em;overflow:scroll;">


<tr><td colspan="4" class="sectionheader"> GUI Functions
<pre>
--------------------------------------------------------------------------------
Introduction
--------------------------------------------------------------------------------

The MultiPROBE Script Language (or MSL) contains an API that allows the script
writer to develop a user interface that is consistent with the Windows NT or
Windows 95 environments.

The script communicates to the user through dialog boxes.  Two kinds of dialog
boxes are available through MSL.  They are "canned" and "custom".

    A "canned" dialog is created via a single function call.  Script execution
    is then paused until the user dismisses the dialog.
    Information is passed between the script and the dialog via parameters in
    the function's argument list as well as the returned value of the function.
    The available canned dialogs include a file selection dialog box and a
    message/query dialog.

    A "custom" dialog is build by the script.  The script creates a dialog and
    then populates that dialog with various controls.  A control may be a label,
    push button, list box, etc.
    Script execution is not paused unless it explicitly waits for a single
    control or the first of a list of controls to be affected (i.e. clicked or
    edited) by the user.  The script could also wait for all of a list of
    controls to be affected.
    Information may be passed between the script and the dialog through a 
    polling function and/or by associating a script variable with each (or some)
    of the controls in the dialog.  These variables will be updated as the
    value of the control is changed by the user.

For more information on the canned dialog boxes, see the section titled
"Canned Dialog Functions".

More detail regarding customized dialog boxes is included in the following
sections.

--------------------------------------------------------------------------------
Customized Dialog Overview
--------------------------------------------------------------------------------

MSL provides functions to create both dialog boxes as well as controls within
those dialog boxes.  These controls may be static (i.e. labels, group boxes) or
they may be dynamic (i.e. edit boxes, push buttons).

The script must assign each dialog and control it creates an integer identifier.
The dialog box ID must be unique among all dialogs created by the script that
exist concurrently.  The control ID must be unique among all controls that
exist in the same dialog box.  Both dialog and control IDs must be in the
range of 1 - 65279.  IDs 65280 - 65535 are reserved for MSL.

When referencing a dialog, you need the dialog id.  When referencing a control,
you need the dialog id and the control id.

All controls may be visible or invisible, enabled or disabled.  When visible,
they may be seen on the parent dialog box.  When invisible, they still exist
but are not shown on the dialog.  When enabled, they have a solid color.
When disabled, they are greyed and (if dynamic) cannot be changed by the
user.  Some dynamic controls may also be considered enabled but read-only.
That is, they have a solid appearence but are not alterable by the user
(at this time, only the edit box and toggle button controls may be read-only).

Static controls are given an initial label, size and position when they are
created.  Although its label cannot be changed by the user, it may be
reloaded by the script at anytime during its existance.

Dynamic controls are also given an initial label, value (or values; Push Btns
have no value) as well as size and position when they are created.  These values
may be changed at anytime by the script.  The user may also change the values as
long as the control is visible and enabled.
When created, the dynamic control may be passed the address of a variable that
will be updated as the "value" of the control changes.  Dynamic controls may
also be polled by the script to obtain their current value.

Both static an dynamic controls may be repositioned and/or resized at any time
by the script.

The script may wait for a certain control or list of controls to be "clicked"
on (or edited) by the user.  The duration of this wait may be specified by the
script.

Multiple controls may be linked together into a collection control.  The
collection control is not in itself a visible control, but it can be treated
like a normal control in that you may render it visible or invisible, enabled
or disabled.  When doing so, all controls that are part of the collection are
effected.  When deleting a collection, the script may indicate if the member
controls should also be deleted.
In addition to IDs of normal controls, a collection may also contain the ID of
one or more other collections (which may themselves contain collections, etc.).
However, there is a limit of 4 collection nesting levels and no collection may
contain the ID of a "parent" collection.

One or more controls may be "slaved" to another control.  That is, their
visibility and/or enable state depend on the value of the "master" control.
Any control may be a slave.  Only dynamic controls may be masters (except
for the push button).  A collection, like any other control, may be a slave.
However, it may not be a master control as it has no value.

For example, a combo box may contain a list of setup catagories.  Several
collections of controls may be slaved to certain values of the combo box.
At any one time, depending on the current value (or selection), a single
collection of controls is in view.  Changing the selection automatically
changes the collection of controls that are visible.


The following controls are available for customized dialog boxes...

    Collection
    Combo Box
    Edit Box
    Group Box
    Information Bar
    Label
    List Box
    Push Button
    Radio Button
    Scroll Bar
    Toggle Button

--------------------------------------------------------------------------------
Specific Dynamic Control Capabilities
--------------------------------------------------------------------------------

Combo Boxes
    Also known as a drop down list, the combo box allows the user to select
    a single entry from a list of posible entries.
    When not in use, the combo box displays only the current selection.

Edit Boxes
    An edit box is a control in which text may be displayed and/or entered
    via the keyboard.  It may contain one or several lines of text.
    Its contents may be defined at create time as "TEXT", "INT" or "DOUBLE".
    If "INT" or "DOUBLE", low and/or high limits may be specified.  The user
    will not be allowed to enter a value that exceeds the limit(s).
    In addition, left/right arrows may be added in order to provide "spin
    control".  In this case, low and high limits are required as well as an
    increment value.
    If "TEXT", the low and high limits refer to the min/max number of
    characters that may be entered.

Information Bar
    By default, every dialog box will have an information bar.  The bar will
    appear along the base of the dialog box.  It will display the help text of
    the control that has input focus.  Each dynamic control create function
    has an argument where help text may be supplied.
    In addition, you may display string followed by a % done indicator.
    You may periodically update the value of the % done indicator.  When
    the work is complete, the information line reverts back help text for
    the last control that had input focus.

List Boxes
    A list box is used to enumerate a list of text strings.  The list may
    exceed the height (in text lines) of the list box.
    The list box may be configured to allow single or multiple selections.
    Two list boxes may be linked together so that entries may be moved
    from one list to the other by single (or double) clicking on an entry.
    One of the two may be designated as a fixed list so that entries in its
    list are copied (not moved) to the other list box.
    When linked, the list box will not allow multiple simultainious selections.

    Another feature is the ability to specify a list of controls that are
    dependent on the list box's current selection.  This dependency is in
    regard to the value that is displayed in the control.  That is, the
    list box may represent a list of data records.  Controls may exist
    whose displayed value must change as the selected record in the list
    box changes.  To accomplish this automatically, the script must do
    the following.

        1. When creating each editable control (edit box, toggle btn, etc.),
           specify the start address of an array of values in the "pVal"
           parameter.  All editable controls have a pVal argument in
           their respective create functions.

        2. Create the list box.  Be sure to specify a iMaxEntries value
           that corresponds to the size of the data arrays passed to
           each control.

        3. Pass a list of the record dependent controls to the
           MSL_ListRecDepControls() function.  If several controls are
           already part of a collection control, the collection control
           ID may be specified instead of the individual control IDs.
           The list could even be a mix of individual control IDs and
           collection control IDs.

Push Buttons
    Push buttons may be given any label.  What happens when they are clicked
    is up to the script.  The script can find out if a button has been clicked
    by polling its state periodically or by waiting until the user clicks it.
    A button may be designated as a dialog dismiss button.  If clicked, the
    dialog on which it appears will be hidden.

Radio Buttons
    A radio button has only two values (On/Off).  When grouped with other
    radio buttons, only one button in the group may be on.  It's similar
    to the combo box except that all possible selections are in view at once.

Scroll Bars
    A scroll bar is a vertical or horizontal bar whose value is represented
    by a box that travels along the length of the bar.
    You do not need to create a scroll bar for multi-line text edit or list
    box controls.  In those cases, scroll bars appear automatically.
    You might explicitly create a scroll bar so that the user may select
    between a range of values.
    In order to let the user view the current value, you may associate the
    scroll bar with an existing edit box, group box or label control.
    If you associate the scroll bar with a label or group box, the value
    displayed cannot be changed except via the scroll bar.  If you associate
    it with an edit box, it may be changed via edit box and/or the scroll bar.
    When creating a scroll bar, you must specify the minimum and maximum
    values allowed.  You must also specify single as well as page increment
    values.  The increment values must evenly divide into the difference
    between the max and min values.

Toggle Buttons
    A toggle button has only two values (On/Off).

--------------------------------------------------------------------------------
API Summary
--------------------------------------------------------------------------------

Canned Dialog Functions:
    These functions display the dialog immediately and do not return to the
    caller until the user dismisses them.

    int MSL_MessageDialog    (iDlgParent, pszTitle, pszMsg, iIcon, iBtn,
                              iDefBtn, iFlags);
    int MSL_SelectFileDialog (iDlgParent, pszTitle, pszFilterSpec,
                              pszDefExt, pszInitDir, pszFilePath, iMaxPath,
                              pszFileName, iMaxName, piROnly, iFlags);


Customized Dialog Functions:
    Newly created dialogs are invisible until explicitely shown.

    int MSL_CreateDialog        (iDlgParent, iDlg, iX, iY, iWidth, iHeight,
                                 pszTitle, iFlags);
    int MSL_DeleteAllDialogs    (iWaitOnly);
    int MSL_DeleteDialog        (iDlg, iFlags);
    int MSL_GetAvailableDialogId();
    int MSL_SetDialogCursor     (iDlg, iCursor);
    int MSL_SetDialogTitle      (iDlg, pszTitle, iFlags);
    int MSL_ShowDialog          (iDlg, iVisible, iFlags);



Create Control Functions:
    Newly created controls are visible or will be visible when the dialog is
    made visible.

    int MSL_CreateCollection(iDlg, iCon, piConList, iControls, iFlags);
    int MSL_CreateComboBox  (iDlg, iCon, iX, iY, iWidth, iHeight, pszLabel,
                             pszHelp, pszVal, iMaxLen, iFlags);
    int MSL_CreateEditBox   (iDlg, iCon, iX, iY, iWidth, iHeight, pszLabel,
                             pszHelp, pvVal, pszType, dMinVal, dMaxVal, dIncVal,
                             iMaxLines, iFlags);
    int MSL_CreateGroupBox  (iDlg, iCon, iX, iY, iWidth, iHeight, pszLabel,
                             iFlags);
    int MSL_CreateLabel     (iDlg, iCon, iX, iY, iWidth, iHeight, pszLabel,
                             iFlags);
    int MSL_CreateListBox   (iDlg, iCon, iX, iY, iWidth, iHeight, pszLabel,
                             pszHelp, pszVal, iMaxLen, iMinEntries, iMaxEntries,
                             iFlags);
    int MSL_CreatePushBtn   (iDlg, iCon, iX, iY, iWidth, iHeight, pszLabel,
                             pszHelp, iRes1, iRes2, iFlags);
    int MSL_CreateRadioBtn  (iDlg, iCon, iX, iY, iWidth, iHeight, pszLabel,
                             pszHelp, piVal, iGrp, iFlags);
    int MSL_CreateScrollBar (iDlg, iCon, iX, iY, iSize, pszHelp, *pdVal,
                             dMinVal, dMaxVal, dSingInc, dPageInc, iAttachCon,
                             iFlags);
    int MSL_CreateToggleBtn (iDlg, iCon, iX, iY, iWidth, iHeight, *pszLabel,
                             pszHelp, piVal, iFlags);


Push Button Functions:
    int MSL_BtnSetFileDialog (iDlg, iCon, iTargetCon, pszTitle, pszFilterSpec,
                              pszDefExt, pszInitDir, pszFilePath, iMaxPath,
                              pszFileName, iMaxName, piROnly, iFlags);


Radio/Toggle Button Functions:
    int MSL_BtnGetValue (iDlg, iCon);
    int MSL_BtnSetValue (iDlg, iCon, iValue);

Edit Box Functions:
    int MSL_EditGetValue  (iDlg, iCon, pvValue, iMaxLen);
    int MSL_EditReadFile  (iDlg, iCon, pszFile, iAppend);
    int MSL_EditSetLimits (iDlg, iCon, dMinVal, dMaxVal, dIncVal, iFlags);
    int MSL_EditSetValue  (iDlg, iCon, pvValue, iAppend);
    int MSL_EditWriteFile (iDlg, iCon, pszFile, iAppend);

Information Bar Functions:
    int MSL_InfoShowProg (iDlg, pszLabel, iProgress, pszStep);
    int MSL_InfoShowHelp (iDlg);

List/Combo Box Functions:
    int  MSL_ListDelIndex       (iDlg, iCon, iIndex);
    int  MSL_ListDelValue       (iDlg, iCon, pszStr);
    void MSL_ListFreeSelValue   (ppszStr, iEntries);
    int  MSL_ListGetEntries     (iDlg, iCon);
    int  MSL_ListGetSelValue    (iDlg, iCon, ppszStr, iMaxEntries);
    int  MSL_ListGetSelIndex    (iDlg, iCon, piSelList, iMaxEntries);
    int  MSL_ListGetValue       (iDlg, iCon, iIndex, pszStr, iMaxLen);
    int  MSL_ListLink           (iDlg, iLst1, iLst2, iFixedLst, iClicks);
    int  MSL_ListLoadValues     (iDlg, iCon, pszItems, iDelimiter, iAppend);
    int  MSL_ListReadFile       (iDlg, iCon, pszFile, iAppend);
    int  MSL_ListRecDepControls (iDlg, iCon, piConList, iControls);
    int  MSL_ListSetSelValue    (iDlg, iCon, pszStr, iExclusive);
    int  MSL_ListSetSelIndex    (iDlg, iCon, iIndex, iExclusive);
    int  MSL_ListSetValue       (iDlg, iCon, iIndex, pszStr, iReplace);
    int  MSL_ListWriteFile      (iDlg, iCon, pszFile, iAppend);

Scroll Bar Functions:
    double MSL_ScrollGetValue  (iDlg, iCon);
    int    MSL_ScrollSetLimits (iDlg, iCon, dMinVal, dMaxVal, dSingInc,
                                dPageInc, iFlags);
    double MSL_ScrollSetValue  (iDlg, iCon, dValue);

Generic Control Functions:
    int MSL_DeleteControl        (iDlg, iCon, iMembers);
    int MSL_EnableControl        (iDlg, iCon, iState);
    int MSL_GetControlGeom       (iDlg, iCon, piX, piY, piWidth, piHeight);
    int MSL_GetAvailableControlId();
    int MSL_SetControlFocus      (iDlg, iCon);
    int MSL_SetControlLabel      (iDlg, iCon, pszLabel);
    int MSL_SetControlMaster     (iDlg, iCon, iConMaster, pvVal, dRange, iAction,
                                  iFlags);
    int MSL_SetControlPos        (iDlg, iCon, iX, iY, iWidth, iHeight, iRes,
                                  iFlags);
    int MSL_ShowControl          (iDlg, iCon, iVisible);
    int MSL_UpdateControl        (iDlg, iCon);
    int MSL_WaitControl          (iDlg, iCon, double dTimeout);
    int MSL_WaitControlList      (iDlg, piConList, iControls, dTimeout, iAll);

Misc Functions:
    int   MSL_Beep          (iFreq, dDuration);
    void  MSL_GetScreenSize (piScrWidth, piScrHeight, piChrWidth, piChrHeight);

Unless specified otherwise, all positions and sizes are in units of character
widths and heights.  By default text will be proportionally spaced.
If position and size values are negative, they will be considered as pixel
units.
</pre>
<tr><td>  MSL_CreateDialog
  <td>  Creates a single dialog box.
  <td>
  <td class="func-call">

int MSL_CreateDialog (      // Returns zero if successful
    int iDlgParent,         // Optional ID of parent dialog.
                            //  If zero, the script execution window
                            //  will be considered the parent.
    int iDlg,               // ID to be assigned to the new dialog box.
    int iX,                 // Offset from upper left corner of script wndw.
                            // If -1, will center horizontally.
    int iY,                 // Offset from upper left corner of script wndw.
                            // If -1, will center vertically.
    int iWidth,             // Width of dialog box.
                            // If -1, will autosize based on controls
    int iHeight,            // Height of dialog box.
                            // If -1, will autosize based on controls
    char *pszTitle,         // Text to appear in the dialog banner
    int iFlags)             // Flag bits (Shown in HEX; ORed together)
                            //  1 => Suppress Information Bar
<tr><td> MSL_DeleteDialog
  <td> Deletes (removes from screen, frees resources) the specified
      dialog box.
  <td>
  <td class="func-call">
int MSL_DeleteDialog (        // Returns zero if successful
   int iDlg,                  // ID of dialog box to delete
   int iFlags)                // Reserved Flags Field
<tr><td> MSL_DeleteAllDialogs
  <td> Deletes (removes from screen, frees resources) all script generated boxes.
  <td>
  <td class="func-call">
int MSL_DeleteAllDialogs (      // Returns zero if successful
   int iWaitOnly)              // Reserved Flags Field
<tr><td> MSL_SetDialogCursor
  <td> To change the cursor that appears over a dialog box.
  <td>
  <td class="func-call">
int MSL_SetDialogCursor (      // Returns zero if no error
   int iDlg,                   // ID of dialog where cursor displayed
   int iCursor)                // Desired cursor
                               //  0 = Arrow (default)
                               //  1 = Application Starting Cursor
                               //  2 = Wait Cursor
<tr><td> MSL_SetDialogTitle
   <td>Replaces the current dialog title with the specified title.
   <td>
	<td class="func-call">
int MSL_SetDialogTitle (        // Returns zero if successful
    int iDlg,                   // ID of dialog box to affect
    char *pszTitle,             // New title string
    int iFlags)                 // Reserved Flags Field
<tr><td> MSL_ShowDialog
  <td> Causes the specified dialog box to be displayed or hidden.
  <td>
  <td class="func-call">
int MSL_ShowDialog (            // Returns zero if successful
    int iDlg,                   // ID of dialog box to affect
    int iVisible,               // Visibility state
                                // 0 => Hidden, ~0 => Visible
    int iFlags)                 // Reserved Flags Field
<tr><td> MSL_GetAvailableDialogId
   <td>  To return to the caller an unused dialog id.
   <td>
	<td class="func-call">
int MSL_GetAvailableDialogId()  // Returns the next available dialog id
<tr><td> MSL_GetAvailableControlId
  <td>To return to the caller an unused control id from the specified dialog.
  <td>
  <td class="func-call">
int MSL_GetAvailableControlId(  // Returns the next available control id
    int iDlg )                  // ID of dialog in which to search
<tr><td> MSL_MessageDialog
  <td>To display a message and wait for the user to respond.
  <td> Control will not return to the caller until one of the
      buttons on the dialog has been clicked.
  <td class="func-call">
int MSL_MessageDialog (     // Returns selected button
                            //    0 => Message Box Failed
                            //    1 => OK
                            //    2 => Cancel
                            //    3 => Retry
                            //    4 => Abort
                            //    5 => Ignore
                            //    6 => Yes
                            //    7 => No
   int  iDlgParent,            // Optional ID of parent dialog
   char *pszTitle,             // Text to appear in title bar
   char *pszMsg,               // Text to appear in window
   int  iIcon,                 // Icon selection
                               //    0 => none
                               //    1 => Information
                               //    2 => Exclamation
                               //    3 => Question
                               //    4 => Stop
   int  iBtn,                  // Button selection
                               //    1 => OK
                               //    2 => OK/Cancel
                               //    3 => Retry/Cancel
                               //    4 => Abort/Retry/Ignore
                               //    5 => Yes/No
                               //    6 => Yes/No/Cancel
   int  iDefBtn,               // Default button (1-3)
   int  iFlags)                // Reserved flags field
<tr><td> MSL_SelectFileDialog
   <td> Display a file selection dialog box.
   <td> Control will not return to the caller until a file selection
      has been made or the user selected the cancel button.
   <td class="func-call">
int MSL_SelectFileDialog (  // Returns zero if file selected
    int  iDlgParent,        // Optional ID of parent dialog
    char *pszDlgTitle,      // Optional Title of File Selection Dialog
    char *pszFilterSpec,    // Optional File Filter Specification
                            //  (i.e. "Text Files (*.txt; *.t)|*.txt;*.t|All Files (*.*)|*.*||" )
    char *pszDefExt,        // Optional Default File Extension
    char *pszInitDir,       // Optional Initial Directory
    char *pszFilePath,      // Returned full file path (dir\name) selected by user
    int  iMaxPath,          // Maximum length of path string
    char *pszFileName,      // Returned file name only (no dir) selected by user
    int  iMaxName,          // Maximum length of name string
    int  *piROnly,          // Returned read only flag setting
    int iFlags)             // Flag bits (Shown in HEX;  ORed together)
                            //  1 => Make this a Save as dialog
<tr><td> MSL_CreateCollection
  <td> Creates a collection control.
  <td> A collection control allows the script writer to affect
   multiple controls with a single function call.
  <td class="func-call">
int MSL_CreateCollection (      // Returns zero if successful
    int iDlg,                   // ID of dialog where control to appear
    int iCon,                   // ID to be assigned to control
    int *piConList,             // List of existing controls
                                //  May be a comma dilimited string
    int iControls,              // Number of controls in list
                                //  Must be zero if ConList is a string
    int iFlags)                 // Reserved Flags Field
<tr><td> MSL_CreateComboBox
   <td> Creates a combo (or drop down list) box control.
   <td>
	<td class="func-call">
int MSL_CreateComboBox (        // Returns zero if successful
    int iDlg,                   // ID of dialog where control to appear
    int iCon,                   // ID to be assigned to control
    int iX,                     // Location in spaces from left
    int iY,                     // Location in spaces from top
    int iWidth,                 // Horizontal size of control
    int iHeight,                // Vertical size of control
    char *pszLabel,             // Optional label.  By default, the label
                                //  appears to the left of the combo box.
                                //  A flag may be specified to make it
                                //  appear on top (left justified).
    char *pszHelp,              // Optional help text.
    char *pszVal,               // Optional address of variable to contain
                                // the current selection.
    int iMaxLen,                // Max length of user supplied variable.
    int iFlags)                 // Flag bits (Shown in HEX; ORed together)
                                //  1 => Use monospaced font for contents
                                //  2 => Use monospaced font for label
                                //  4 => Indicates that the label (if
                                //       specified) must appear on top of
                                //       the combo box.
                                //400 => Auto sort list alphabetically.
<tr><td> MSL_CreateEditBox
  <td> Creates an edit box control.
  <td>
  <td class="func-call">
int MSL_CreateEditBox (         // Returns zero if successful
    int iDlg,                   // ID of dialog where control to appear
    int iCon,                   // ID to be assigned to control
    int iX,                     // Location in spaces from left
    int iY,                     // Location in spaces from top
    int iWidth,                 // Horizontal size of control
    int iHeight,                // Vertical size of control
    char *pszLabel,             // Optional label.  By default, the label
                                //  appears to the left of the edit box.
                                //  A flag may be specified to make it
                                //  appear on top (left justified).
    char *pszHelp,              // Optional help text.
    void *pvVal,                // Optional address of variable to contain
                                // the current edit box value.
    char *pszType,              // Edit box type: "TEXT", "INT" or "DOUBLE"
                                //  If "TEXT", a max nbr chars is required!
    double dMinVal,             // Optional Min value (or min nbr characters)
    double dMaxVal,             // Optional Max value (or max nbr characters)
    double dIncVal,             // Value increment/decrement.  Make non-
                                //  zero if spin control desired.  Not valid
                                //  for "TEXT" mode edit boxes
    int iMaxLines,              // If not zero, the maximum number of lines
                                //  of text that may be stored box
                                //  If zero, the number if lines are limited only
                                //  by the capacity of the edit box.
    int iFlags)                 // Flag bits (Shown in HEX;  ORed together)
                                //  1 => Use monospaced font for contents
                                //  2 => Use monospaced font for label
                                //  4 => Indicates that the label (if
                                //       specified) must appear on top of
                                //       the edit box.
                                //  8 => Read only flag.  If set, the value
                                //       of the edit box cannot be changed
                                //       by the user
                                // 10 => Value required flag.  If set, user
                                //       will be forced to enter a value
                                //       before dialog is auto dismissed
                                // 20 => Use Min value
                                // 40 => Use Max value
                                // 80 => Multiline Text Box
                                //100 => Center Text (multiline only)
                                //200 => Right Justify Text (multiline only)
                                //2000=> Include a horizontal scroll bar
<tr><td> MSL_CreateGroupBox
   <td> Creates a group box control.
   <td>
	<td class="func-call">
int MSL_CreateGroupBox (        // Returns zero if successful
    int iDlg,                   // ID of dialog where control to appear
    int iCon,                   // ID to be assigned to control
    int iX,                     // Location in spaces from left
    int iY,                     // Location in spaces from top
    int iWidth,                 // Horizontal size of control
    int iHeight,                // Vertical size of control
    char *pszLabel,             // Text to appear in upper left corner
                                // of the group box
    int iFlags)                 // Flag bits (Shown in HEX;  ORed together)
                                //  1 => Use monospaced font for contents
 
/******************************************************************************/



/*******************************************************************************
*
*   Function:   MSL_CreateLabel
*
*   Purpose:    Creates a text label control.
*
*   Notes:      The width and height are dermined by the number of "\n"
*               imbeded in the string and the max length of each line.
*
*   Revised:    5/15/1995   TLG     Original
*
*   Method: */

    int MSL_CreateLabel (           // Returns zero if successful
        int iDlg,                   // ID of dialog where control to appear
        int iCon,                   // ID to be assigned to control
        int iX,                     // Location in spaces from left
        int iY,                     // Location in spaces from top
        int iWidth,                 // Horizontal size of control
        int iHeight,                // Vertical size of control
        char *pszLabel,             // Text to appear in the label
        int iFlags)                 // Flag bits (Shown in HEX;  ORed together)
                                    //   1 => Use monospaced font for contents
                                    // 100 => Center Text
                                    // 200 => Right Justify Text
                                    //1000 => Put a border around the label
 
/******************************************************************************/



/*******************************************************************************
*
*   Function:   MSL_CreateListBox
*
*   Purpose:    Creates a list box control.
*
*   Notes:
*
*   Revised:    5/15/1995   TLG     Original
*
*   Method: */

    int MSL_CreateListBox (         // Returns zero if successful
        int iDlg,                   // ID of dialog where control to appear
        int iCon,                   // ID to be assigned to control
        int iX,                     // Location in spaces from left
        int iY,                     // Location in spaces from top
        int iWidth,                 // Horizontal size of control
        int iHeight,                // Vertical size of control
        char *pszLabel,             // Optional label.  By default, the label
                                    //  appear on top of the list box.
        char *pszHelp,              // Optional help text.
        char *pszVal,               // Optional address of variable to contain
                                    //  the current selection.
        int iMaxLen,                // Max length of user supplied variable.
        int iMinEntries,            // Minimum required entries.  This value
                                    //  would be checked after an auto hide,
                                    //  auto verify push button is invoked.
                                    //  If an insufficent number of entries
                                    //  exist, the user will be notified.
        int iMaxEntries,            // Maximun number of entries allowed.
                                    //  As records are added to the list box
                                    //  this value will be checked.  If the
                                    //  number will exceed the limit one of
                                    //  two possible actions will take place
                                    //   1. If entry appended via script, the
                                    //      top entry will be deleted.
                                    //   2. If entry added via user through
                                    //      a linked list box, that entry will
                                    //      be suppressed and a beep will be
                                    //      sounded.
        int iFlags)                 // Flag bits (Shown in HEX;  ORed together)
                                    //  1 => Use monospaced font for contents
                                    //  2 => Use monospaced font for label
                                    // 10 => Multiple Selection flag.  If set,
                                    //       more than one entry may be
                                    //       selected at the same time.
                                    //400 => Auto sort list alphabetically.
 
/******************************************************************************/



/*******************************************************************************
*
*   Function:   MSL_CreatePushBtn
*
*   Purpose:    Creates a push button control.
*
*   Notes:
*
*   Revised:    5/15/1995   TLG     Original
*
*   Method: */

    int MSL_CreatePushBtn (         // Returns zero if successful
        int iDlg,                   // ID of dialog where control to appear
        int iCon,                   // ID to be assigned to control
        int iX,                     // Location in spaces from left
        int iY,                     // Location in spaces from top
        int iWidth,                 // Horizontal size of control
        int iHeight,                // Vertical size of control
        char *pszLabel,             // Text to appear in the push button
        char *pszHelp,              // Optional help text.
        int iRes1,                  // Reserved Arg 1
        int iRes2,                  // Reserved Arg 2
        int iFlags)                 // Flag bits (Shown in HEX;  ORed together)
                                    //  1 => Use monospaced font for contents
                                    // 10 => Default btn flag.  If set, this
                                    //       button will be the default btn.
                                    // 20 => Auto Hide flag.  If set, the dialog
                                    //       will be dismissed when the user
                                    //       clicks on this button.
                                    // 40 => Auto Verify flag.  If set, all
                                    //       edit boxes with the required flag
                                    //       set, will be checked to see if a
                                    //       value has been entered before the
                                    //       dialog may be auto dismissed.
                                    //       If an edit box is found that has
                                    //       not been initialized, the user
                                    //       will be signaled.
                                    //800 => Disabled unless being waited for
                                    //       with MSL_WaitControl() or
                                    //       MSL_WaitControlList()

/******************************************************************************/



/*******************************************************************************
*
*   Function:   MSL_CreateRadioBtn
*
*   Purpose:    Creates a radio button control.
*
*   Notes:
*
*   Revised:    5/15/1995   TLG     Original
*
*   Method: */

    int MSL_CreateRadioBtn (        // Returns zero if successful
        int iDlg,                   // ID of dialog where control to appear
        int iCon,                   // ID to be assigned to control
        int iX,                     // Location in spaces from left
        int iY,                     // Location in spaces from top
        int iWidth,                 // Horizontal size of control
        int iHeight,                // Vertical size of control
        char *pszLabel,             // The button's text label
        char *pszHelp,              // Optional help text.
        int *piVal,                 // Address of variable to contain state
        int iGrp,                   // Radio group id
        int iFlags)                 // Flag bits (Shown in HEX;  ORed together)
                                    //  1 => Use monospaced font for contents
                                    // 20 => Display the label to the left of the
                                    //       radio button

/******************************************************************************/



/*******************************************************************************
*
*   Function:   MSL_CreateScrollBar
*
*   Purpose:    Creates a scroll bar control.
*
*   Notes:      The scroll bar may be attached to an edit box, label or
*               group box.  The attached control (if any) will display the
*               current value of the scroll bar.  If an edit box is used (and
*               it's not in read-only mode), it may be used to change the
*               value of the scroll bar.
*
*   Revised:    5/15/1995   TLG     Original
*
*   Method: */

    int MSL_CreateScrollBar (       // Returns zero if successful
        int iDlg,                   // ID of dialog where control to appear
        int iCon,                   // ID to be assigned to control
        int iX,                     // Location in spaces from left
        int iY,                     // Location in spaces from top
        int iSize,                  // Length in spaces of bar.  This may
                                    //  be vertical or horizontal depending on
                                    //  the value of the flags field.
        char *pszHelp,              // Optional help text.
        double *pdVal,              // Optional address of variable to contain
                                    //  the current scroll bar value.
        double dMinVal,             // Minimum value of the scale bar
        double dMaxVal,             // Maximum value of the scale bar
        double dSingInc,            // Single step increment value
        double dPageInc,            // Page step increment value
        int    iAttachCon,          // Optional ID attached control.  Must be
                                    //  an edit box, label or group box
        int    iFlags)              // Flag bits (Shown in HEX;  ORed together)
                                    // 10 => Orient scroll bar vertically.
                                    //       By default it will be horizontal
                                    // 20 => Flip direction of increasing value
                                    //       Def: left to right; Top to Bottom

/******************************************************************************/



/*******************************************************************************
*
*   Function:   MSL_CreateToggleBtn
*
*   Purpose:    Creates a toggle button control.
*
*   Notes:
*
*   Revised:    5/15/1995   TLG     Original
*
*   Method: */

    int MSL_CreateToggleBtn (       // Returns zero if successful
        int iDlg,                   // ID of dialog where control to appear
        int iCon,                   // ID to be assigned to control
        int iX,                     // Location in spaces from left
        int iY,                     // Location in spaces from top
        int iWidth,                 // Horizontal size of control
        int iHeight,                // Vertical size of control
        char *pszLabel,             // The button's text label
        char *pszHelp,              // Optional help text.
        int *piVal,                 // Address of variable to contain state
        int iFlags)                 // Flag bits (Shown in HEX;  ORed together)
                                    //  1 => Use monospaced font for contents
                                    //  8 => Read only flag.  If set, the state
                                    //       of the toggle button cannot be changed
                                    //       by the user
                                    // 20 => Display the label to the left of the
                                    //       toggle button

/******************************************************************************/



/*******************************************************************************
*
*   Function:   MSL_BtnSetSelectFile
*
*   Purpose:    Configures a push button to create a file selection dialog
*               box when it (the button) is clicked.
*
*   Notes:      The selected file (if any) will be stored in the caller
*               provided buffers (pszFilePath and pszFileName) as well as
*               the specified target control (i.e. an edit control).
*
*   Revised:    5/15/1995   TLG     Original
*
*   Method: */

    int MSL_BtnSetSelectFile (	// Returns zero if successful
        int iDlg,               // ID of dialog where control exists
        int iCon,               // ID of push button control
        int iTargetCon,         // ID of control to receive selected file text
        char *pszDlgTitle,	    // Optional Title of File Selection Dialog
        char *pszFilterSpec,    // Optional File Filter Specification
                                //  (i.e. "Text Files (*.txt; *.t)|*.txt;*.t|All Files (*.*)|*.*||" )
        char *pszDefExt,        // Optional Default File Extension
        char *pszInitDir,       // Optional Initial Directory
        char *pszFilePath,      // Returned full file path (dir\name) selected by user
        int  iMaxPath,          // Maximum length of path string
        char *pszFileName,      // Returned file name only (no dir) selected by user
        int  iMaxName,          // Maximum length of name string
        int  *piROnly,          // Returned read only flag setting
        int iFlags)             // Flag bits (Shown in HEX;  ORed together)
                                //  1 => Make this a Save as dialog

/******************************************************************************/



/*******************************************************************************
*
*   Function:   MSL_BtnGetValue
*
*   Purpose:    Gets the value of a toggle or radio button control
*
*   Notes:
*
*   Revised:    5/15/1995   TLG     Original
*
*   Method: */

    int MSL_BtnGetValue (           // Returns button value (0=Off, 1=On)
        int iDlg,                   // ID of dialog where control exists
        int iCon)                   // ID of control

/******************************************************************************/



/*******************************************************************************
*
*   Function:   MSL_BtnSetValue
*
*   Purpose:    Sets the value of a toggle or radio button control
*
*   Notes:
*
*   Revised:    5/15/1995   TLG     Original
*
*   Method: */

    int MSL_BtnSetValue (           // Returns previous button value
                                    //  (0=Off, 1=On)
        int iDlg,                   // ID of dialog where control exists
        int iCon,                   // ID of control
        int iValue)                 // New button value (0=Off, ~0=On)

/******************************************************************************/



/*******************************************************************************
*
*   Function:   MSL_EditGetValue
*
*   Purpose:    Gets the value of an edit box control
*
*   Notes:
*
*   Revised:    5/15/1995   TLG     Original
*
*   Method: */

    int MSL_EditGetValue (          // Returns zero if successful
        int iDlg,                   // ID of dialog where control exists
        int iCon,                   // ID of control
        void *pvValue,              // Pointer to buffer to receive value.
                                    //  Actual type depends on the edit box
                                    //  type (i.e. "TEXT", "INT" or "DOUBLE")
        int iMaxLen)                // If in "TEXT" mode, the max length of
                                    //  the string buffer specified by pvValue. 

/******************************************************************************/



/*******************************************************************************
*
*   Function:   MSL_EditReadFile
*
*   Purpose:    Loads an edit box with the contents of the specified file.
*
*   Notes:      This function is only valid for edit boxes of type "TEXT"
*
*   Revised:    5/15/1995   TLG     Original
*
*   Method: */

    int MSL_EditReadFile (          // Returns zero if successful
        int iDlg,                   // ID of dialog where control exists
        int iCon,                   // ID of control
        char *pszFile,              // Name of File to be loaded.
        int iAppend)                // If set, the file contents will
                                    //  be appended to rather than replace the
                                    //  current edit box value.

/******************************************************************************/



/*******************************************************************************
*
*   Function:   MSL_EditSetLimits
*
*   Purpose:    To set the limits/increment of an edit box
*
*   Notes:      Only valid for edit boxes of type "INT" or "DOUBLE".
*               If called for an edit box of type "TEXT" it will be
*               ignored.
*               If the ID of this edit box was passed to the 
*               MSL_CreateScrollBar() function such that it is now
*               displaying the value of the scroll bar, this call
*               will be ignored.
*
*   Revised:    5/15/1995   TLG     Original
*
*   Method: */

    int MSL_EditSetLimits (         // Returns zero if successful
        int iDlg,                   // ID of dialog where control exists
        int iCon,                   // ID of control
        double dMinVal,             // Minimum value of the scale bar
        double dMaxVal,             // Maximum value of the scale bar
        double dIncVal,             // Single step increment value
        int iFlags)                 // Reserved flags field

/******************************************************************************/



/*******************************************************************************
*
*   Function:   MSL_EditSetValue
*
*   Purpose:    Sets the value of an edit box control
*
*   Notes:
*
*   Revised:    5/15/1995   TLG     Original
*
*   Method: */

    int MSL_EditSetValue (          // Returns zero if successful
        int iDlg,                   // ID of dialog where control exists
        int iCon,                   // ID of control
        void *pvValue,              // Pointer to value.  Actual type depends
                                    //  on the edit box type (i.e. "TEXT", "INT"
                                    //  or "DOUBLE")
        int iAppend)                // If set and in "TEXT" mode, value will
                                    //  be appended to rather than replace the
                                    //  current edit box value.

/******************************************************************************/



/*******************************************************************************
*
*   Function:   MSL_EditWriteFile
*
*   Purpose:    Writes the contents of the edit box to the specified file.
*               If the file does not exist, it will be created.
*
*   Notes:      This function is only valid for edit boxes of type "TEXT"
*
*   Revised:    5/15/1995   TLG     Original
*
*   Method: */

    int MSL_EditWriteFile (         // Returns zero if successful
        int iDlg,                   // ID of dialog where control exists
        int iCon,                   // ID of control
        char *pszFile,              // Name of File to be opened/created
        int iAppend)                // If set, text will be appended to
                                    //  the end of the file.  Otherwise
                                    //  the entire file will be replaced.

/******************************************************************************/



/*******************************************************************************
*
*   Function:   MSL_InfoShowProg
*
*   Purpose:    Displays a label followed by a % complete indicator.
*
*   Notes:
*
*   Revised:    5/15/1995   TLG     Original
*
*   Method: */

    int MSL_InfoShowProg (          // Returns zero if successful
        int iDlg,                   // ID of dialog where control exists
        char *pszLabel,             // Label to display in info bar
        int  iProgress,             // Value indicates % complete
        char *pszStep)             // Optional current step string

/******************************************************************************/



/*******************************************************************************
*
*   Function:   MSL_InfoShowHelp
*
*   Purpose:    Puts the information bar back into the mode where it
*               displays the help associated with the control that has
*               input focus.
*
*   Notes:      You need only call this function after using the
*               MSL_InfoShowProg() function.
*
*   Revised:    5/15/1995   TLG     Original
*
*   Method: */

    int MSL_InfoShowHelp (          // Returns zero if successful
        int iDlg)                   // ID of dialog where control exists

/******************************************************************************/



/*******************************************************************************
*
*   Function:   MSL_ListDelIndex
*
*   Purpose:    Deletes the list box entry indicated by the index
*
*   Notes:      List box indexes start at zero.
*
*   Revised:    5/15/1995   TLG     Original
*
*   Method: */

    int MSL_ListDelIndex (          // Returns zero if successful
        int iDlg,                   // ID of dialog where control exists
        int iCon,                   // ID of control
        int iIndex)                 // Index of list box entry to delete.

/******************************************************************************/



/*******************************************************************************
*
*   Function:   MSL_ListDelValue
*
*   Purpose:    Deletes the list box entry with a matching value
*
*   Notes:
*
*   Revised:    5/15/1995   TLG     Original
*
*   Method: */

    int MSL_ListDelValue (          // Returns zero if successful
        int iDlg,                   // ID of dialog where control exists
        int iCon,                   // ID of control
        char *pszStr)               // String to identify list box entry.

/******************************************************************************/



/*******************************************************************************
*
*   Function:   MSL_ListGetEntries
*
*   Purpose:    Returns the total number of entries in a list box.
*
*   Notes:
*
*   Revised:    5/15/1995   TLG     Original
*
*   Method: */

    int MSL_ListGetEntries (        // Returns number of list box entries
        int iDlg,                   // ID of dialog where control exists
        int iCon)                   // ID of control

/******************************************************************************/



/*******************************************************************************
*
*   Function:   MSL_ListFreeSelValue
*
*   Purpose:    To free the memory allocated by the MSL_ListGetSelValue()
*               function.
*
*   Notes:      This function should be called each time MSL_ListGetSelValue
*               is invoked (after the selections have been inspected/copied)
*               to free the memory that had been allocated for each
*               selection.
*
*   Revised:    5/15/1995   TLG     Original
*
*   Method: */

    void MSL_ListFreeSelValue (     // Returns number of selections
        char **ppszStr,             // Pointer an array where string pointers
                                    //  are currently loaded.
        int  iEntries)              // Number of array entries.

/******************************************************************************/



/*******************************************************************************
*
*   Function:   MSL_ListGetSelValue
*
*   Purpose:    Returns the current list/combo box selection(s).
*
*   Notes:      For each selection, this function allocates memory.  This
*               memory should be freed when the caller is finished inspecting
*               and/or coping the list of selections.
*               Use MSL_ListFreeSelValue() to release that memory.  Just pass
*               it the array of string pointers and the number of selections
*               that was returned by this function.
*
*   Revised:    5/15/1995   TLG     Original
*
*   Method: */

    int MSL_ListGetSelValue (       // Returns number of selections
        int iDlg,                   // ID of dialog where control exists
        int iCon,                   // ID of control
        char **ppszStr,             // Pointer an array where string pointers
                                    //  may be loaded.
        int  iMaxEntries)           // Max number of array entries.

/******************************************************************************/



/*******************************************************************************
*
*   Function:   MSL_ListGetSelIndex
*
*   Purpose:    Returns the current list/combo box selection(s).
*
*   Notes:
*
*   Revised:    5/15/1995   TLG     Original
*
*   Method: */

    int MSL_ListGetSelIndex (       // Returns number of selections
        int iDlg,                   // ID of dialog where control exists
        int iCon,                   // ID of control
        int *piSelList,             // Pointer an array where indexes of the
                                    //  selected list entries are stored
        int  iMaxEntries)           // Max number of array entries.

/******************************************************************************/



/*******************************************************************************
*
*   Function:   MSL_ListGetValue
*
*   Purpose:    Returns a specific list box entry.
*
*   Notes:
*
*   Revised:    5/15/1995   TLG     Original
*
*   Method: */

    int MSL_ListGetValue (          // Returns the actual length of the string
        int iDlg,                   // ID of dialog where control exists
        int iCon,                   // ID of control
        int iIndex,                 // Index of list box entry to fetch
        char *pszStr,               // Address of string buffer to be loaded
        int  iMaxLen)               // Max size of string buffer.

/******************************************************************************/



/*******************************************************************************
*
*   Function:   MSL_ListLink
*
*   Purpose:    To link to list boxes together so that entries may be moved
*               from one to the other or (in the case of a fixed list)
*               copied from the fixed list to the non-fixed list.
*
*   Notes:
*
*   Revised:    5/15/1995   TLG     Original
*
*   Method: */

    int MSL_ListLink (              // Returns zero if successful
        int iDlg,                   // ID of dialog where controls exist
        int iCon1,                  // ID of first list box
        int iCon2,                  // ID of second list box
        int iFixedCon,              // ID of the fixed list (if any).  Must
                                    //  match iCon1 or iCon2 or be zero.
        int iClicks)                // Number of Btn clicks required to
                                    //  move/copy entries from one list to
                                    //  another (1 or 2)

/******************************************************************************/



/*******************************************************************************
*
*   Function:   MSL_ListLoadValues
*
*   Purpose:    Loads the an array of strings into the list box.
*               Each string becomes an entry in the list box.
*
*   Notes:
*
*   Revised:    5/15/1995   TLG     Original
*
*   Method: */

    int MSL_ListLoadValues (        // Returns zero if successful
        int iDlg,                   // ID of dialog where control exists
        int iCon,                   // ID of control
        char *pszItems,             // String with one or more items
        int iDelimiter,             // Item delimiter character
        int iAppend)                // If set, file data will be appended to
                                    //  existing entries.  Otherwise, any
                                    //  existing entries will be replaced.

/******************************************************************************/



/*******************************************************************************
*
*   Function:   MSL_ListReadFile
*
*   Purpose:    Loads the contents of a ASCII file into the list box.
*               Each line of the file becomes an entry in the list box.
*
*   Notes:
*
*   Revised:    5/15/1995   TLG     Original
*
*   Method: */

    int MSL_ListReadFile (          // Returns zero if successful
        int iDlg,                   // ID of dialog where control exists
        int iCon,                   // ID of control
        char *pszFile,              // Name of file to read
        int iAppend)                // If set, file data will be appended to
                                    //  existing entries.  Otherwise, any
                                    //  existing entries will be replaced.

/******************************************************************************/



/*******************************************************************************
*
*   Function:   MSL_ListRecDepControls
*
*   Purpose:    Specifies the controls whose value is dependent on the
*               current selection index of this list or combo box,
*
*   Notes:      The specified controls will be ignored if the list box
*               is in multiselection mode.
*
*               When any control that has a user changable value is created
*               by the script, it may be passed an address of where to store
*               that value.  It's this address that may be dependent on
*               what entry (or record) in a list box is currently selected.
*
*               Therefore, when the current selection index changes (whether
*               by user or by script), all record dependent controls will be
*               updated with the appropriate offset to employ when accessing
*               the value address assigned to them.
*
*   Revised:    5/15/1995   TLG     Original
*
*   Method: */

    int MSL_ListRecDepControls (    // Returns zero if successful
        int iDlg,                   // ID of dialog where control exists
        int iCon,                   // ID of control
        int *piConList,             // List of record dependent controls
        int iControls)              // Number of controls in list.

/******************************************************************************/


/*******************************************************************************
*
*   Function:   MSL_ListSetSelValue
*
*   Purpose:    Allows the caller to specify the value of the entry that
*               should be selected.
*
*   Notes:      If in multi-select mode, no existing selections will be
*               removed unless the "iExclusive" flag is set.
*               If in single-select mode, the existing selection (if any)
*               will be removed regardless of the value of the "iExclusive"
*               flag.
*               If the specified value is not already in the list box,
*               the function will do nothing.
*
*   Revised:    5/15/1995   TLG     Original
*
*   Method: */

    int MSL_ListSetSelValue (       // Returns zero if successful
        int iDlg,                   // ID of dialog where control exists
        int iCon,                   // ID of control
        char *pszStr,               // Value of entry to be selected.
        int  iExclusive)            // If set, any existing selections will be
                                    //  removed (multi-selection mode only)

/******************************************************************************/



/*******************************************************************************
*
*   Function:   MSL_ListSetSelIndex
*
*   Purpose:    Allows the caller to specify the index of the entry that
*               should be selected.
*
*   Notes:      If in multi-select mode, no existing selections will be
*               removed unless the "iExclusive" flag is set.
*               If in single-select mode, the existing selection (if any)
*               will be removed regardless of the value of the "iExclusive"
*               flag.
*               If the specified index is not already in the list box,
*               the function will do nothing.
*
*   Revised:    5/15/1995   TLG     Original
*
*   Method: */

    int MSL_ListSetSelIndex (       // Returns zero if successful
        int iDlg,                   // ID of dialog where control exists
        int iCon,                   // ID of control
        int iIndex,                 // Index of entry to be selected.
        int iExclusive)             // If set, any existing selections will be
                                    //  removed (multi-select mode only)

/******************************************************************************/



/*******************************************************************************
*
*   Function:   MSL_ListSetValue
*
*   Purpose:    Allows the caller to specify the value of an entry at a
*               specific index.  By default the entry will be inserted
*               into the list rather than replace an existing entry.
*
*   Notes:      If the specified index exceeds the number of entries in the
*               list box, the value will be added at the end of the list.
*
*   Revised:    5/15/1995   TLG     Original
*
*   Method: */

    int MSL_ListSetValue (          // Returns zero if successful
        int iDlg,                   // ID of dialog where control exists
        int iCon,                   // ID of control
        int iIndex,                 // Index of entry to be loaded
        char *pszStr,               // New value of entry
        int iReplace)               // If set, an existing entry (at the
                                    //  specified index) will be replaced
                                    //  rather than be moved down in the list.

/******************************************************************************/



/*******************************************************************************
*
*   Function:   MSL_ListWriteFile
*
*   Purpose:    Writes the contents of the list box to a file.
*               Each list box entry becomes a separate line of text in
*               the file.
*               If the file does not exist, it will be created
*
*   Notes:
*
*   Revised:    5/15/1995   TLG     Original
*
*   Method: */

    int MSL_ListWriteFile (         // Returns zero if successful
        int iDlg,                   // ID of dialog where control exists
        int iCon,                   // ID of control
        char *pszFile,              // Name of file to opened/created
        int iAppend)                // If set, text will be appended to
                                    //  the end of the file.  Otherwise
                                    //  the entire file will be replaced.

/******************************************************************************/



/*******************************************************************************
*
*   Function:   MSL_ScrollGetValue
*
*   Purpose:    Gets the value of a scroll bar control
*
*   Notes:
*
*   Revised:    5/15/1995   TLG     Original
*
*   Method: */

    double MSL_ScrollGetValue (     // Returns scale value
           int iDlg,                // ID of dialog where control exists
           int iCon)                // ID of control

/******************************************************************************/



/*******************************************************************************
*
*   Function:   MSL_ScrollSetLimits
*
*   Purpose:    To set the scrolling limits/increment of a scroll bar.
*
*   Notes:
*
*   Revised:    5/15/1995   TLG     Original
*
*   Method: */

    int MSL_ScrollSetLimits (       // Returns zero if successful
        int iDlg,                   // ID of dialog where control exists
        int iCon,                   // ID of control
        double dMinVal,             // Minimum value of the scale bar
        double dMaxVal,             // Maximum value of the scale bar
        double dSingInc,            // Single step increment value
        double dPageInc,            // Page step increment value
        int iFlags)                 // Reserved flags field

/******************************************************************************/



/*******************************************************************************
*
*   Function:   MSL_ScrollSetValue
*
*   Purpose:    Sets the value of a scroll bar control
*
*   Notes:      The new value will be adjusted if necessary so that
*               it is an exact multiple of increments from the
*               minimum scroll value.
*
*   Revised:    5/15/1995   TLG     Original
*
*   Method: */

    double MSL_ScrollSetValue (      // Returns previous scroll value
           int iDlg,                // ID of dialog where control exists
           int iCon,                // ID of control
           double dValue)           // New value of the scale bar

/******************************************************************************/



/*******************************************************************************
*
*   Function:   MSL_DeleteControl
*
*   Purpose:    Removes control from dialog and frees any resources
*               associated with the control.
*
*   Notes:      If the specified control is a collection, and the members
*               flag is set, all members of the collection will be deleted.
*
*   Revised:    5/15/1995   TLG     Original
*
*   Method: */

    int MSL_DeleteControl (         // Returns zero if successful
        int iDlg,                   // ID of dialog where control exists
        int iCon,                   // ID of control
        int iMembers)               // If set and a collection control, delete
                                    //  all members of the collection as well. 

/******************************************************************************/



/*******************************************************************************
*
*   Function:   MSL_EnableControl
*
*   Purpose:    To set the control's enabled/disabled state.
*
*   Notes:      If the specified control is a collection, all members
*               of the collection will be affected.
*
*   Revised:    5/15/1995   TLG     Original
*
*   Method: */

    int MSL_EnableControl (         // Returns current enable/disable state
        int iDlg,                   // ID of dialog where control exists
        int iCon,                   // ID of control
        int iEnable)                // New enable state (0=Disabled, 1=Enabled)
                                    //  If -1, no state change will be made

/******************************************************************************/



/*******************************************************************************
*
*   Function:   MSL_GetControlGeom
*
*   Purpose:    To fetch the specified control's location and size.
*
*   Notes:      The returned values are in pixel units!  The X,Y values
*               refer to the upper left hand corner of the control.
*
*   Revised:    5/15/1995   TLG     Original
*
*   Method: */

    int MSL_GetControlGeom (        // Returns zero if successful
        int iDlg,                   // ID of dialog where control exists
        int iCon,                   // ID of control
        int *piX,                   // Pointer to X location buffer
        int *piY,                   // Pointer to Y location buffer
        int *piWidth,               // Pointer to Width buffer
        int *piHeight)              // Pointer to Height buffer

/******************************************************************************/



/*******************************************************************************
*
*   Function:   MSL_SetControlFocus
*
*   Purpose:    To set input focus to a particular control within a dialog
*               box.  This function will do nothing if the specified
*               control is not dynamic, visible and enabled.
*               However, if the control is a collection, the first dynamic,
*               visible control in the collection will receive input focus.
*
*   Notes:      When a dialog box is shown for the first time, the first
*               created dynamic/enabled control will receive input focus.
*               After that, the user may change which control has input
*               focus by using the TAB key or by clicking on a control
*               with the mouse.
*               You would use this function to direct the user's attention
*               to a specific control.
*
*   Revised:    5/15/1995   TLG     Original
*
*   Method: */

    int MSL_SetControlFocus (       // Returns zero if successful
        int iDlg,                   // ID of dialog where control exists
        int iCon)                   // ID of control to receive input focus

/******************************************************************************/



/*******************************************************************************
*
*   Function:   MSL_SetControlLabel
*
*   Purpose:    To set the label text for a control.
*
*   Notes:      This function will be ignored if the specified control does
*               not have a label associated  with it.
*
*   Revised:    5/15/1995   TLG     Original
*
*   Method: */

    int MSL_SetControlLabel (       // Returns zero if successful
        int iDlg,                   // ID of dialog where control exists
        int iCon,                   // ID of control
        char *pszLabel)             // Pointer to the new label text

/******************************************************************************/



/*******************************************************************************
*
*   Function:   MSL_SetControlMaster
*
*   Purpose:    To make the specified control a slave of some other
*               existing control.
*
*   Notes:      You may use this function to free a slave control by making
*               the value of the master control ID zero.
*
*   Revised:    5/15/1995   TLG     Original
*
*   Method: */

    int MSL_SetControlMaster (      // Returns zero if successful
        int iDlg,                   // ID of dialog where controls exist
        int iCon,                   // ID of control
        int iConMaster,             // ID of master control. Set to zero to
                                    // free a slave control from its master.
        void *pvValue,              // Required master control value for slave
                                    //  control to be enabled and/or visible.
                                    //  The type of value depends on the
                                    //  the master control type.
                                    //  For edit boxes, this may be null to
                                    //  indicate that a blank edit box enables
                                    //  and/or shows the slave control.
        double dRange,              // If the master control's value is a
                                    //  double or integer, a range may be
                                    //  specified.  If the value of the master
                                    //  falls within this range, it's considered
                                    //  a match.
                                    //  i.e.  (base <= value <= base+range)
        int iAction,                // Action to take if value matches or
                                    //  falls within the specified range.
                                    //  1 => Enable Control
                                    //  2 => Disable Control
                                    //  3 => Show Control
                                    //  4 => Hide Control
        int iFlags)                 // Flag bits (Shown in HEX;  ORed together)
                                    //  1 => Do nothing if there is no match
                                    //       By default the opposite action
                                    //       (of the one specified) will be
                                    //       taken.
                                    //  2 => If master a list or combo box
                                    //       control, consider value an index.
                                    //       Otherwise it's a string.
                                    //  4 => If master an edit, list or combo
                                    //       box control, consider any non-null
                                    //       value as the required state.
                                    //       Otherwise an exact match must be
                                    //       made in order to take the specified
                                    //       action on the control.
                                    //  8 => Do action if master value does
                                    //       not match the specified value.

/******************************************************************************/



/*******************************************************************************
*
*   Function:   MSL_SetControlPos
*
*   Purpose:    To set the position and/or size of the control.
*
*   Notes:      This function will not operate on a collection control.
*
*   Revised:    5/15/1995   TLG     Original
*
*   Method: */

    int MSL_SetControlPos (         // Returns zero if no error
        int iDlg,                   // ID of dialog where control exists
        int iCon,                   // ID of control
        int iX,                     // New X location of control origin
        int iY,                     // New Y location of control origin
        int iWidth,                 // New width of control
        int iHeight,                // New height of control
        int iRes,                   // Reserved argument
        int iFlags)                 // Flag bits (Shown in HEX;  ORed together)
                                    //   1 => Update origin
                                    //   2 => Update size

/******************************************************************************/



/*******************************************************************************
*
*   Function:   MSL_ShowControl
*
*   Purpose:    To set the control's visibility state.
*
*   Notes:
*
*   Revised:    5/15/1995   TLG     Original
*
*   Method: */

    int MSL_ShowControl (           // Returns previous visibility state
        int iDlg,                   // ID of dialog where control exists
        int iCon,                   // ID of control
        int iVisible)               // New visibility state (0=Hide, 1=Show)
                                    //  If -1, no state change will be made

/******************************************************************************/



/*******************************************************************************
*
*   Function:   MSL_UpdateControl
*
*   Purpose:    To refresh the displayed value in the control
*
*   Notes:
*
*   Revised:    2/18/1997   TLG     Original
*
*   Method: */

    int MSL_UpdateControl (         // Returns zero if no error
        int iDlg,                   // ID of dialog where control exists
        int iCon )                  // ID of control

/******************************************************************************/



/*******************************************************************************
*
*   Function:   MSL_WaitControl
*
*   Purpose:    To pause script execution until the specified control is
*               affected or the timeout expires.
*
*   Notes:
*
*   Revised:    5/15/1995   TLG     Original
*
*   Method: */

    int MSL_WaitControl (           // Returns ID of control if it changed.
                                    //  Returns zero if timeout expired.
        int iDlg,                   // ID of dialog where control exists
        int iCon,                   // ID of control
        double dTimeout)            // Wait timeout (in seconds)
                                    //  A value of -1 means wait forever

/******************************************************************************/



/*******************************************************************************
*
*   Function:   MSL_WaitControlList
*
*   Purpose:    To pause script execution until any one (or all) of specified
*               controls is (are) affected or the timeout expires.
*
*   Notes:
*
*   Revised:    5/15/1995   TLG     Original
*
*   Method: */

    int MSL_WaitControlList (       // Returns ID of 1st control that changed.
                                    //  Returns zero if timeout expired.
        int iDlg,                   // ID of dialog where controls exist
        int *piConList,             // Array of control IDs
                                    //  May be a comma delimited string
        int iControls,              // Number of controls in the array
                                    //  Must be zero if using string
        double dTimeout,            // Wait timeout (in seconds)
                                    //  A value of -1 means wait forever
        int iAll)                   // If set, wait for all controls rather
                                    //  than just the first to be affected.

/******************************************************************************/



/*******************************************************************************
*
*   Function:   MSL_Beep
*
*   Purpose:    To generate simple tones on the speaker.
*
*   Notes:      This is the WIN32 Beep() function
*
*   Revised:    5/15/1995   TLG     Original
*
*   Method: */

    int MSL_Beep (                  // Returns zero if successful
        int iFreq,                  // Sound frequency (in Hz)
        double dDuration)           // Sound Duration (in seconds)
                                    //  If -1 specified, sound continues
                                    //  until MSL_Beep is called again.

/******************************************************************************/




/*******************************************************************************
*
*   Function:   MSL_GetScreenSize
*
*   Purpose:    To fetch the system's screen size as well the average
*               size of a character.
*
*   Notes:      The returned values are in pixel units!  The character
*               width &amp; height are used internally to convert character
*               coordinates into pixel coordinates
*               
*
*   Revised:    5/15/1995   TLG     Original
*
*   Method: */

    void MSL_GetScreenSize (            // No return value
        int *piScrWidth,                // Returned Screen Width
        int *piScrHeight,               // Returned Screen Height
        int *piChrWidth,                // Returned Avg Character Width
        int *piChrHeight)               // Returned Avg Character Height

/******************************************************************************/

<tr><td colspan="4" class="sectionheader"> Remote Functions
<pre>
MSLREMOTE.C:  MSL Remote Modules

Doc_Start:

Remote Overview:
---------------

The Remote Module provides a set of functions for interfacing with the
following remote devices:
    * Disk Files
    * COMM Ports

Two levels of support are provided:  basic text string I/O support and
"AutoStart" support.

Basic I/O Functions:
-------------------

    * Send or get one line of text
    * Timeout and retry capability
    * Can be called directly from MSL script, or can be hooked into MSL
        pipette operation or error callback functions for almost unlimited
        flexibility


AutoStart Support:
-----------------

(Currently not implemented)


Doc_End:
</pre>

<tr><td> MSL_RemoteClearDevices
 <td>Clears data for all the remote devices.  This function
    should be called once and only once on startup.  Calling it
   again later, could destroy devices already in use.
 <td>
 <td class="func-call">
int MSL_RemoteClearDevices(     // SUCCESS
     void)
<tr><td> MSL_RemoteOpenCOMM
 <td> A remote device object is opened for the specified COMM port.
     An error is returned if the device has already been opened.
 <td>The remove device object and COMM port itself are opened here.
    If either has already been opened, an error code is returned.
    A remote data structure is initialized and a handle to the
    device returned.  Note that this "handle" is simply the index
    into the internal remote device array, and not the actual
    operating system handle.
 <td class="func-call">
int MSL_RemoteOpenCOMM(   // FAIL or handle to device
  int iPort,              // COMM port
  char *pszTerminators)   // ptr to string of termination characters, eg:
                                  // "\r\n\t" terminates input on carriage
                                  // return, linefeed, or tab
<tr><td> MSL_RemoteOpenFile
  <td> A remote device object is opened for the specified filenames.
      An error is returned if the device has already been opened.
  <td>
  <ul><li>In the case of a file based remote device, the file itself is
    not actually opened here--it is opened and closed anytime it is
    written or read.  Rather, a remote device data structure is
    initialized and a handle to the device returned.  Note that
    this "handle" is simply the index into the internal remote
    device array, and not the actual operating system handle.
   <li> Two filenames must be provided--one for read (get) and one
     for write (send).  These could be the same.</ul>
  <td class="func-call">
int MSL_RemoteOpenFile(     // FAIL or handle to device
   char *pszGetFilename,   // get filename
   char *pszSendFilename,  // send filename
   char *pszTerminators)   // ptr to string of termination characters, eg:
                           // "\r\n\t" terminates input on carriage
                           // return, linefeed, or tab
<tr><td> MSL_RemoteCloseDevice
  <td> The specified remote device is closed.
  <td>
  <td class="func-call">
int MSL_RemoteCloseDevice(  // FAIL or SUCCESS
   int iDevice)            // handle to remote device
            
<tr><td>  MSL_RemoteCloseAll
  <td> Closes all remote devices.
  <td>
  <td class="func-call">
int MSL_RemoteCloseAll(     // FAIL or SUCCESS
    void)
<tr><td>  MSL_RemoteSetCOMMOptions
 <td> Sets the COMM port options for the specified remote device.
 <td>
 <td class="func-call">
int MSL_RemoteSetCOMMOptions(   // FAIL or SUCCESS
    int iDevice,                // handle to remote device
    int iBaudRate,              // actual baud rate
    int iParity,                // parity: 0=no,1=odd,2=even,3=mark,4=space
    int iDataBits,              // # bits per byte [4-8]
    int iStopBits)              // # stop bits: 0=1, 1=1.5, 2=2
<tr><td>MSL_RemoteGetString
  <td>Reads data from specified remote device.  The device structure
  contains device parameters such as the device type, termination
  characters, etc.
  <td>
  <ul>
  <li>Reads characters until either a terminator character is read,
     the buffer is full, or a timeout occurs.
  <li>Returned buffer always includes a NULL terminator.  Thus, the
      maximum characters returned is the buffer size minus one.
  <li>If terminator character not read, the characters read until
     the timeout are still returned.
  <li>Number of characters read (piNumRead) includes any terminator
 character read, but not the string terminating NULL character.
  </ul>
  <p>
  <b>Purge Options (file type device only):</b>
   <ul>
	<li>PURGE_NONE:  Data is not purged
   <li>PURGE_BEFORE:  File is deleted before reading.  Currently,
       not supported.  Should include retrys and timeout.
   <li>PURGE_AFTER:  File is deleted after reading.
   <li>PURGE_READ:  Only data read is deleted (NOT supported!)
	</ul>
  <td class="func-call">
 int MSL_RemoteGetString(    // SUCCESS or FAIL
    int iDevice,            // handle to remote device
    int iFilePurgeOption,   // purge option for file type device:
                            // PURGE_NONE or PURGE_AFTER
    int iSize,              // max length of input string
    int iTimeout,           // timeout in seconds
    int *piNumRead,         // ptr to number of chars read in
    char *pBuffer)          // storage buffer for input characters
<tr><td>MSL_RemoteSendString
 <td>Sends string to specified remote device.  The device structure
    contains device parameters such as the device type, etc.
 <td>
  <ul>
  <li>This function allows printf style output.  IE, the output
string can be a simple string, or a printf type control
string followed by optional arguments.
  <li>The number of characters output in the formatted string
is returned to caller.
  <li> For file type remove devices, the send file can optionally
 be purged first.  If the file is not to be purged, then
 the new string is appended to the end of any existing file.
  </ul>
 <td class="func-call">
  int MSL_RemoteSendString(     // SUCCESS or FAIL
        int iDevice,            // handle to remote device
        int iFilePurgeOption,   // purge option for file type device:
                                //   PURGE_NONE or PURGE_BEFORE
        int iTimeout,           // timeout in seconds
        int *piNumWritten,      // ptr to number of chars sent
        char *pszString,        // string to send
        ...)                    // additional printf style arguments
<tr><td colspan="4" class="sectionheader"> Rack Functions
<br>Function Return Codes:
<ul>
<li>SUCCESS =  0
<li>FAIL    = -1
</ul>
<tr><td>MSL_RackLoadId
 <td>To load the rack id into the specified rack node.
 <td>
 <td class="func-call">
  int MSL_RackLoadId(     // FAIL or SUCCESS
      char* pszRackName,   // name of rack
      char* pszRackId )    // rack id string
<tr><td>MSL_RackOpenEx
 <td>The specified rack file is read in, "positioned" on the deck,
       and added to the Pipette Module's rack layout.
<p>
 The rack positions are converted from a position relative to
 a grid hole location (A1, B1, ...) and rack frame corner to
 an absolute deck location.  The rack can then be used for
 pipetting and is referenced using the supplied rack name.
 <td>
 <td class="func-call">
  int MSL_RackOpenEx(         // FAIL or SUCCESS
      char *pszRackName,      // name of rack
      char *pszRackFile,      // name of rack file
      int nGridRow,           // Index of grid pin row (0='A')
      int nGridColumn,        // Index of grid pin column (0='1')
      double dRotation,       // Rack rotation (i.e. degrees; 0,90,180 and 270)
      char *pszRackId,        // Default Rack identifier (eg, barcode name)
      BOOL bReqRackId )       // Flag to request rack id
<tr><td> MSL_PlateOpenEx
 <td>The specified rack file is read in, "positioned" on the plate
     support, and added to the Pipette Module's rack layout.
 <p>  Before a plate can be positioned, the support must first
      be opened (via MSL_RackOpenEx).  This positions the
      support to an absolute location on the deck.  Then the plate
      can be opened which positions the plate on the specified
      support and support position, both in X-Y and in Z.
<p>
           The plate X-Y positions are relative to the plate frame's
           upper left frame corner.  The absolute location of the
           specified support and position on the support is then added
           to each of the plate locations.
<p>
           The support's maximum travel is added to each of the plate
           height dimensions.  The maximum travel is the height of the
           support where the plate sits.  The safe travel height is
           set to the maximum of the plate safe height on the support, or
           the support safe travel height.
<p>
           The plate can then be used for pipetting and is referenced
           using the supplied rack name.
 <td>
   Note1:      If the specified rack name has already been opened, this
           function simply returns SUCCESS.

 <td class="func-call">
  int MSL_PlateOpenEx(            // FAIL or SUCCESS
      char *pszRackName,          // name of rack (plate)
      char *pszRackFile,          // name of rack file
      char *pszPlateSupportName,  // name of plate support
      int iPositionOnSupport,     // position on plate support
      double dRotation,           // Plate rotation (i.e. degrees; 0,90,180 and 270)
      char *pszRackId,            // Rack identifier (eg, barcode name)
      BOOL bReqRackId )           // Flag to request rack id
            
<tr><td> MSL_RackCopySampleIds
 <td>To copy the sample ids cached in the specified source rack's
           position array to the position array of the destination rack.
 <td>
 <td class="func-call">
    int MSL_RackCopySampleIds(  // FAIL or SUCCESS
        char *szSrcRack,        // Name of source rack
        char *szDstRack )       // Name of destination rack.  If "" or NULL
                                //  the rack list will be searched for any
                                //  of the same type and location as the
                                //  source rack.
<tr><td> MSL_RackClose
 <td> The specified rack name is removed from the Pipette Module's
           rack layout.  All associated resources are freed.
 <td>
 <td class="func-call">
    int MSL_RackClose(          // FAIL or SUCCESS
        char *szRackName)       // name of rack

<tr><td> MSL_RackCloseAll
 <td>All rack names are removed from the Pipette Module.
           All associated resources are freed.
 <td>
 <td class="func-call">
     void MSL_RackCloseAll(void)

<tr><td> MSL_RackCheckOpen
 <td>Checks if specified rack is in the Pipette Module's rack layout.
 <td>
 <td class="func-call">
    int MSL_RackCheckOpen(      // FAIL=no, SUCCESS=yes
        char *szRackName)       // name of rack file
            
<tr><td> MSL_RackDumpLayout
 <td>The current rack layout is written to the specified ASCII
     dump file.  The rack layout consists of all the "open" racks.
 <table>
 <tr><th>Column  <th>Description
 <tr><td>  1     <td> The name of the rack/plate.
 <tr><td>  2     <td> The file containing the rack/plate definition
 <tr><td>  3     <td> The Y grid location (zero based: 0 to  6)
 <tr><td>  4     <td>  The X grid location (zero based: 0 to 23)
 <tr><td>  5     <td>  The rack/plate rotation (i.e. 0, 90, 180 or 270)
 <tr><td>  6     <td>  The rack/plate id required flag.  If non-zero, an assembly
           change will be triggered when the rack/plate is opened so
           that the initial rack/plate id may be requested.
 <tr><td> 7      <td>If a plate, The rack name of the support upon which the
           plate is to be placed.
 </table>
 <td>
 <td class="func-call">
  int MSL_RackDumpLayout(     // FAIL or SUCCESS
      char *szFileName)       // name of rack dump file

<tr><td> MSL_RackGetUnit
 <td>Copies the RACKUNIT structure of a rack for the specified
           rack name and position to the specified RACKUNIT buffer.
 <td><ul><li> Unit is 1 based (not 0; for now there is only one unit/rack).
        <li> Rack must be opened.
        <li>RACKUNIT size must be provided to prevent data overun in
               the event that the script and MSL rack versions are not
               the same.
       </ul>
 <td class="func-call">
  int MSL_RackGetUnit(        // FAIL or SUCCESS
       char *szRackName,       // name of rack
       int iUnit,              // unit number in rack (1 based)
       RACKUNIT *pUnit,        // pointer to RACKUNIT structure
       int iSize)              // size of RACKUNIT structure

<tr><td>MSL_RackSetUnit
 <td>Copies the caller specified RACKUNIT structure to the
           specified rack name.  The MSL_RackGetUnit function should
           be called first to initialize the RACKUNIT structure.
 <td><ul><li> Position is 1 based (not 0).
   <li> Rack must be opened.
   <li> RACKUNIT size must be provided to prevent data overun in
               the event that the script and MSL rack versions are not
               the same.
   </ul>
 <td class="func-call">
   int MSL_RackSetUnit(        // FAIL or SUCCESS
        char *szRackName,       // name of rack
        int iUnit,              // unit number in rack (1 based)
        RACKUNIT *pUnit,        // pointer to RACKUNIT structure
        int iSize)              // size of RACKUNIT structure
<tr><td> MSL_RackGetPosition
 <td>Copies the MP_POSITION structure of a rack for the specified
           rack name and position to the specified MP_POSITION buffer.
 <td><ul><li>Position is 1 based (not 0).
    <li> Rack must be opened.
    <li> MP_POSITION size must be provided to prevent data overun in
               the event that the script and MSL rack versions are not
               the same.
    </ul>
 <td class="func-call">
   int MSL_RackGetPosition(    // FAIL or SUCCESS
        char *szRackName,       // name of rack
        int iPosition,          // position in rack (1 based)
        MP_POSITION *pPosition, // pointer to MP_POSITION structure
        int iSize)              // size of MP_POSITION structure

<tr><td>MSL_RackSetPosition
 <td> Copies the caller specified MP_POSITION structure to the
           specified rack name and position. The MSL_RackGetPosition
           should be called first to initialize the MP_POSITION
           structure.
 <td><ul><li>Position is 1 based (not 0).
    <li> Rack must be opened.
    <li> MP_POSITION size must be provided to prevent data overun in
               the event that the script and MSL rack versions are not
               the same.
    </ul>
 <td class="func-call">
  int MSL_RackSetPosition(    // FAIL or SUCCESS
      char *szRackName,       // name of rack
      int iPosition,          // position in rack (1 based)
      MP_POSITION *pPosition, // pointer to MP_POSITION structure
      int iSize)              // size of MP_POSITION structure

<tr><td colspan="4" class="sectionheader"> Miscellaneous Instrument Functions
<tr><td> MSL_IsInstrumentOpen
 <td> To return a boolean indicating whether or not the
           CAN driver has been opened.
 <td>
 <td class="func-call">
   int MSL_IsInstrumentOpen()      // 0=not open, 1=open

<tr><td> MSL_NumberOfDilutors
 <td>To return the number of tips available on the pipetting arm.
           This value may be 4 or 8.
 <td>
 <td class="func-call">
   int MSL_NumberOfDilutors()      // Returns number of tips in this instrument

<tr><td>EGS_GetEvaluationLevel
 <td>To return the current EGS execution evaluation level.
 <td>In general, the higher the evaluation level, the more
      activities are suppressed.  The following levels are supported:
 <table>
 <tr><td>0   <td>Normal Execution
 <tr><td>1   <td>Generate EGS sequences but don't invoke pre/post step
               callbacks and don't move to targets
 <tr><td>2   <td>Invoke pre/post step callbacks (when specified) but
               don't move to targets.
 <tr><td>3   <td>Move to targets but don't pipette
 </table>
     Assembly change operations are performed regardless of
     the evaluation level.  This prevents the evaluation from
     running indefinately if the user is not there to stop it.
 <td class="func-call">
   int EGS_GetEvaluationLevel()    // Return current level

<tr><td>EGS_SetEvaluationLevel
 <td>To load the EGS execution evaluation level.
 <td>In general, the higher the evaluation level, the more
      activities are suppressed.  The following levels are supported:
 <table>
 <tr><td>0   <td>Normal Execution
 <tr><td>1   <td>Generate EGS sequences but don't invoke pre/post step
               callbacks and don't move to targets
 <tr><td>2   <td>Invoke pre/post step callbacks (when specified) but
               don't move to targets.
 <tr><td>3   <td>Move to targets but don't pipette
 </table>
     Assembly change operations are performed regardless of
     the evaluation level.  This prevents the evaluation from
     running indefinately if the user is not there to stop it.
 <td class="func-call">
   int EGS_SetEvaluationLevel(     // Return previous level
       int iNewLevel )             // The new EGS evaluation level

<tr><td>EGS_SetSingleStep
 <td>To set/clear the EGS single step mode
 <td>A non-zero single step mode implies that EGS execution
           should pause before each step is executed.
 <td class="func-call">
    int EGS_SetSingleStep(     // Return previous state
           int iNewMode )      // The new egs single step mode

<tr><td>EGS_SetNextDilutor
 <td>To set the prefered next dilutor number.
 <td>The term "prefered" is used because if the indicated dilutor
           cannot reach all positions to which it is assigned (in the
           subsequent pipetting sequence), another dilutor will be
           selected internally.
 <td class="func-call">
   int EGS_SetNextDilutor(     // Returns the next dilutor number
       int iDilutor)           // The prefered next dilutor number (1-4)

<tr><td>EGS_GetLiquidOperation
 <td>To retrieve a copy of the EGS operation at the specified index.
 <td>The operation code is optional.  If specified, a value of
           FAIL will be returned if it does not match the operation
           at the specified index.
           CALLABLE ONLY FROM A PRE OR POST STEP FUNCTION!
 <td class="func-call">
   int EGS_GetLiquidOperation(     // SUCCESS or FAIL
       int iEGSStep,               // The EGS step index for the current sequence
       int iOperation,             // Optional EGS operation code (0 if not in use)
       PLIQUIDOP pLiquidOp,        // Address of structure to be loaded
       int iSize)                  // Size (in bytes) of the above liq. operation structure

<tr><td>EGS_SetLiquidOperation
 <td>To load the specified EGS record with the specified liquid
           operation structure.
 <td>The operation code is not optional here.  It must match
     the operation code of the EGS record at the specified index.
           CALLABLE ONLY FROM A PRE OR POST STEP FUNCTION!
 <td class="func-call">
   int EGS_SetLiquidOperation(     // SUCCESS or FAIL
       int iEGSStep,               // The EGS step index for the current sequence
       int iOperation,             // EGS operation code
       PLIQUIDOP pLiquidOp,        // Address of structure to be copied
       int iSize)                  // Size (in bytes) of the above liq. operation structure

<tr><td>MSL_GetEgsContext()
 <td>To return the current EGS context.
 <td>The structure MP2_EGS_CONTEXT is defined in WinPREP.s
 <td class="func-call">
    int MSL_GetEgsContext(          // Return 0 if successful
        MP2_EGS_CONTEXT *pContext,  // Pointer to memory to receive the context.
        int nSize )                 // Size of context structure

<tr><td>MSL_GetErrorContext()
 <td>To return the last error context.
 <td>The structure MP2_ERR_CONTEXT is defined in WinPREP.s
 <td class="func-call">
    int MSL_GetErrorContext(    // Return 0 if successful
    MP2_ERR_CONTEXT *pContext,  // Pointer to memory to receive the context.
    int nSize )                 // Size of context structure

<tr><td>EGS_SetNextDilutor
 <td>To specify the next dilutor to be used.
 <td>Must be a number between 1 and 4.
 <td class="func-call">
     int EGS_SetNextDilutor(int iDilutor)

<tr><td>MSL_AssemChngWellMap
 <td>Support function to execute one or more assembly
           change operations (i.e. one per rack found in the caller
           specified well map).
 <td>
 <td class="func-call">
   int MSL_AssemChngWellMap(       // Returns  0 for SUCCESS
                                   //         -1 for Quit Test
                                   //          2 for Quit Procedure
       MP2_WELLMAP_DEF* pMap )     // Well map structure ptr.

<tr><td>MSL_AssemChngRack
 <td>Support function to execute an assembly change on
           a single rack.
 <td>
 <td class="func-call">
   int MSL_AssemChngRack(          // Returns  0 for SUCCESS
                                   //         -1 for Quit Test
                                   //          2 for Quit Procedure
       char* pszRackName )         // Name of rack to assembly change

<tr><td>MSL_GetLastAssemChngRack()
 <td>To return the current assembly change rack.
 <td>
 <td class="func-call">
   int MSL_GetLastAssemChngRack(   // Returns length of rack name
       char* pszRackName,          // Address of where to store the rack name
       int   nMaxLen )             // Max length of the rack name buffer

<tr><td>EGS_UseMachineSafeTravel
 <td>Specifies which safe travel height to use.  Normally, the
           highest safe travel height of all the racks on the deck is
           used when moving between racks.  This function can be used
           to overide this behavior and use the machine safe travel
           instead.
 <td>
           This is a special purpose function provided for the high level
           utilities.  Allows a diagnostic test be run without
           necessarily having to remove all the labware.
 <td class="func-call">
  int EGS_UseMachineSafeTravel(   // Returns previous value
      int bUseMachine)            // 0=no (use rack safe travel)
                                  // 1=yes (use machine safe travel)

<tr><td> MSL_GetVersionNumbers()
 <td>To return the MSL version numbers
 <td>
 <td class="func-call">
   void MSL_GetVersionNumbers(
       int *pnMajor,      // Ptr to integer to store MSL's major version nbr
       int *pnMinor,      // Ptr to integer to store MSL's minor version nbr
       int *pnBuild )     // Ptr to integer to store MSL's build nbr

<tr><td> MSL_GetSerialNumber()
 <td>To get the serial number of the instrument.
 <td>
 <td class="func-call">
  int MSL_GetSerialNumber(     // Returns 0 if successful
      LPSTR lpszBuffer,        // where to store the result
      int nChars )             // number of characters in buffer

<tr><td>MSL_MarkTipPos
 <td>To set the disposable tip state for the specified tip box
           rack and position.
 <td>
 <td class="func-call">
  int MSL_MarkTipPos(
    char* pszRack,              // Rack name
    int   nWell,                // Well position
    int   nMark)                // Value to mark the position
                                //  -1 : Mark position as unusable
                                //   0 : Mark position as empty
                                //   1 : Mark position as containing a tip.

<tr><td>MSL_ResetTipBoxesDialog()
 <td>Displays a dialog which allows the user to reset the currently open tip boxes.
 <td>
 <td class="func-call">
   int MSL_ResetTipBoxesDialog()

<tr><td>MSL_VerifyLabwareDialog()
 <td> Displays a dialog which allows the user to verify the locations
           of the currently open labware.
 <td>
 <td class="func-call">
   int MSL_VerifyLabwareDialog()

<tr><td>MSL_NetMessageBufferSend()
 <td>To display a dialog box on a caller specific computer (must
           on the network) with a caller specific message.
 <td>
 <td class="func-call">
   int MSL_NetMessageBufferSend( // Returns 0 if successful
       char *pszToName,          // Name of computer to receive message
       char *pszMsg )            // Message text

<tr><td colspan="4" class="sectionheader"> Motor Movement and Pump Functions

<tr><td colspan="4">
<pre>
Summary of the common functions in the mslmove.dll used for
moving motors and pumps.

See also the MoveLoop procedure in the RandomMoveTest diagnostic
in WinPREP for examples of how to use these functions.

Overview of Moving Motors and Pumps:

Typical sequence of function calls to simultaneously move motors and pumps:

- MSL_SetMotorNextMove(i)	Set local parameters for each motor to be moved
- MSL_SetPumpNextMove(i)	Set local parameters fo each pump to be moved
- MSL_AdjustYVSpeeds()          (8 tip only) Adjust Y &amp; V speeds and predelays
- MSL_SendMotorsForward()	Send parameters to all motors
- MSL_SendPumpsForward()	Send parameters to all pumps
- MSL_StartMovementMotors()	Start all motors
- MSL_StartMovementPumps()	Start all pumps
- MSL_WaitForMotorsDone()	Wait for all motors to finish (or fault, abort,...)
- MSL_WaitForPumpsDone()	Wait for all pumps to finish
- MSL_FinishAllMotors()		Update local motor parameters (current position ...)
- MSL_FinishAllPumps()		Update local pump parameters


Motor and pump error handling:

In general, the motors/pumps that faulted should have their movement "canceled"
instead of "finished".  Canceling a movement, essentially, updates parameters
w/o changing the "previous" location which is used for error recovery.

Typical sequence with motor errors and no recovery:
- MSL_SetMotorNextMove(i)	Set local parameters for each motor to be moved
- MSL_SetPumpNextMove(i)	Set local parameters fo each pump to be moved
- MSL_AdjustYVSpeeds()          (8 tip only) Adjust Y &amp; V speeds and predelays
- MSL_SendMotorsForward()	Send parameters to all motors
- MSL_SendPumpsForward()	Send parameters to all pumps
- MSL_StartMovementMotors()	Start all motors
- MSL_StartMovementPumps()	Start all pumps
- MSL_WaitForMotorsDone()	Wait for all motors to finish (or fault, abort,...)
- MSL_FinishMotorMovement(i)    Update parameters for each succesful motor
- MSL_CancelMotorMovement(i)    Update parameters for each faulted motor
- MSL_FinishPumpMovement(i)     Update parameters for each succesful pump
- MSL_CancelPumpMovement(i)     Update parameters for each faulted pump

Typical sequence with motor errors and recovery:
- MSL_SetMotorNextMove(i)	Set local parameters for each motor to be moved
- MSL_AdjustYVSpeeds()          (8 tip only) Adjust Y &amp; V speeds and predelays
- MSL_SendMotorsForward()	Send parameters to all motors
- MSL_StartMovementMotors()	Start all motors
- MSL_WaitForMotorsDone()	Wait for all motors to finish (or fault, abort,...)
- MSL_FinishMotorMovement(i)    Update parameters for each succesful motor
- MSL_SendMotorsBackward()	Send parameters for all unfinished (faulted) motors
                                    back to last good position
- MSL_StartMovement()		Start all faulted motors
- MS_WaitForMotorsDone()	Wait for all motors to finish
User can be queried to either retry (repeat sequence starting with
MSL_SendMotorsForward()), or quit (MSL_CancelPumpMovment(i))


Note for pump recovery:
Although the pump functions are symetric with the motor functions, pump errors
usually cannot be cleared without reinitializing.  Even if recovery were
possible, the sample would still be very questionable.  Since reinitializing
the pump homes the syringe, the initialization should only be done when the
tips have been positioned over an appropriate waste labware.


MslMove Constants
-----------------

The definitions shown here are the ones used internally by mslmove.dll. Custom MSL
script code should use the vales shown below, but remember that MSL does not support
#defines.

// return codes
#define SUCCESS           0

// fatal return codes
#define FAIL              -1
#define USER_ABORT        -2
#define COM_ERROR         -3
	
// non-fatal return codes
#define MOVE_ERROR         1
#define STOP_PROC          2

	
// motor/pump error codes:
// these are used both in the function error arrays and in the
// iModuleMoveError field of the motor &amp; pump objects
#define MOVE_ERROR_FAULT   1
#define MOVE_ERROR_TIMEOUT 2
#define MOVE_ERROR_ESTOP   3
#define MOVE_ERROR_DILUTOR 4

// motor handles
#define XMOTOR             1
#define YMOTOR             2
#define VMOTOR             3
#define BCXMOTOR           4
#define BCYMOTOR           5
#define Z1MOTOR            6
#define Z2MOTOR            7
#define Z3MOTOR            8
#define Z4MOTOR            9
#define STRIPMOTOR        10
#define PERIMOTOR         11
#define Z5MOTOR           12
#define Z6MOTOR           13
#define Z7MOTOR           14
#define Z8MOTOR           15

// Unknown last target
#define LOC_LAST_UNKNOWN    -999999999

// motor types
typedef enum 
{ 
	MOTOR_TYPE_X=1,
	MOTOR_TYPE_Y=2,
	MOTOR_TYPE_Z=3,
	MOTOR_TYPE_V=4,
	MOTOR_TYPE_BCX=5,
	MOTOR_TYPE_BCY=6,
	MOTOR_TYPE_STRIP=7,
	MOTOR_TYPE_PERI=8
} MOTOR_TYPE;


// motor move modes
#define MOVE_MODE_MASK 0x0000ffff	// mask for actual move mode
typedef enum
{
    Z_MOVE_MODE_NORMAL      = 0,
    Z_MOVE_MODE_LIQ_DET     = 1,
    Z_MOVE_MODE_CLOT_DET    = 2,          // should be added in MP 1.5 firmware
    MOVE_MODE_HOME          = 3,          // stop at home sensor (eg stripper)
    MOVE_MODE_FORCE         = 0x00010000, // force next move (ignore last target position)
    MOVE_MODE_REAL          = 0x00020000, // target location is real, not virtual
    MOVE_MODE_NOLOG         = 0x00040000, // DB logging not required (eg, get tip fault)
    MOVE_MODE_MULT_STARTS   = 0x00080000, // allow multiple motor starts
    MOVE_MODE_SONIC_OFF     = 0x00100000, // turn off sonication after motor done
    MOVE_MODE_RET_IMMEDIATE = 0x00200000, // return immediate
    MOVE_MODE_GO_HOME       = 0x00400000  // move to home (real location 0, overide
                                              // calculated virtual target)
} MOTOR_MOVE_TYPE;

// pump move modes
typedef enum
{
    PUMP_MODE_SONIC_OFF     = 0x00010000  // turn off sonication after pump done
} PUMP_MOVE_TYPE;


/* valve positions (in degress) */
#define VALVE_SYRINGE_TO_TIP      0
#define VALVE_PERIPUMP_TO_TIP     90
#define VALVE_PERIPUMP_TO_SYSLIQ  180
#define VALVE_SYRINGE_TO_SYSLIQ   270
</pre>

<tr><td> MSL_SetMotorNextMove
 <td> Sets the target location, speed, ramp, pre-move and post-move
           delays, and move mode for the next move.  This function
           verifies that the motor has been initialized and the motor
           speed is within range.  If the speed or ramp is zero, the
           default motor speed or ramp is used.
 <td>
           The target range check has been moved from here to
           MSL_SendMotorsForward/Backward() where the target location is
           adjusted for deck calibration.  The check is done there since
           the uncalibrated target could be in range, but the calibrated
           target out of range.  Also, the calculation involves X, Y, and
           Z positions together, whereas this function is for an
           individual motor.
 <td class="func-call">
   int MSLMOVE_API
      MSL_SetMotorNextMove(       // FAIL or SUCCESS
          int iMotor,             // motor handle (see #defines)
          double dTargetLoc,      // virtual absolute position in mm
          double dMoveSpeed,      // mm/sec
          int iMoveMode,          // move mode (see #defines)
          double dMoveRamp,       // mm/sec/sec
          int iPreDelay,          // pre-move delay in ms
          int iPostDelay)         // post-move delay in ms

<tr><td>MSL_AdjustYVSpeeds
 <td>For 8 tip (scissor style) varispan assembly, the V motor is really
           a second Y motor.
  <td>
           Since the DSP code treats the V motor as though it's location
           is relative to the Y motor location, the velocity of the V
           motor is in effect added to the velocity of the Y motor
           if both motors are moving.
   <p>
           Therefore if both motors are moving in the same direction
           (at the default speed), the V motor ends up moving twice as
           fast as it should.
   <p>
           This function will calculate the distance each motor is
           moving (in steps) and then split the velocity of the Y
           motor between the two based on the relative magnitudes
           of the moves.
 <td class="func-call">
   void MSLMOVE_API
       MSL_AdjustYVSpeeds()
            
<tr><td>MSL_SendMotorsForward
 <td>Sends motor parameters to the CAN driver in preparation for
           the next move.  Only motors which are initialized and have
           the next move initialized (via MSL_SetMotorNextMove) are
           serviced.  All motors will move to their target location on
           the next MSL_StartMovement call.
 <td><ul><li>
           Prior to sending any commands to the CAN driver, any
           pending faults are first cleared via MSL_ClearMotorMoveError.
  <li>
  New:        Implemented 6-16-98 in BCR release for nL requirement:
           Only motors which are not active (ie, start movement has not
           been called) are processed.  This allows adding the capability
           to start motors at different times and then wait for all to
           complete.  For example, so that Zs can be retracted in nL
           as each one reaches its retract exit pressure.
 <li>
           The active flag is set in start movement and reset in wait for
           motors.  So, multiple calls to this function will now only
           start unstarted motors, but yet once wait has been called, send
           motors forward/backward will still move motors for error
           recovery.</ul>
 <td class="func-call">
   int MSLMOVE_API
       MSL_SendMotorsForward(void);
            
<tr><td> MSL_StartMovementMotors
 <td>Start all loaded motors (send "go" commands).  Called by MSL_StartMovement.
 <td><ul><li>
           If the target position is the same as the previous position
           (ie, no movement required), then the motor state is left
           IDLE and the "go" command not sent.orce a response.
  <li> Rather than relying on the virtual target and previous
           positions, MSL_SendMotorsForward/Backward makes the determination
           by comparing the actual target values being sent to the DSP, and
           then setting a flag in the motor object for use here.  This is
           because the virtual positions can be the same even though
           the real encoder positions are different.  For example, the
           virtual safe travel height before and after picking up a
           disposable tip is the same, but the real position is not
           (the Z motor is recalibrated after getting a DT).</ul>
 <td class="func-call">
   int MSL_StartMovementMotors(    // FAIL or SUCCESS
        void)

<tr><td>MSL_WaitForMotorsDone
 <td>Wait for all motors to finish movement or timeout.  Only
           waits for motors marked active and without errors.
 <td>
 <td class="func-call">
int MSLMOVE_API
       MSL_WaitForMotorsDone(  // FAIL, SUCCESS, USER_ABORT, COM_ERROR, MOVE_ERROR
           int iMinTimeOut)    // minimum wait in sec before timeout

<tr><td> MSL_FinishAllMotors
 <td> "Finishes" the motor move sequence for all motors that have
           been initialized, a move pending, and no error.  This
           function should be called after calling MSL_WaitForMotorsDone
           and only if all the motor moves were successful.  If any
           errors occured, MSL_CancelMotorMovement should be used for
           motors with the error, and MSL_FinishMotorMovement for the
           motors w/o an error.
   <p>
           In addition, a query of the motor location is done if the
           query flag is set.  Typically, a query is not required--since
           the target position is valid if the move was successful.  The
           query mode would be used when moving to liquid.
 <td>
 <td class="func-call">
int MSLMOVE_API
    MSL_FinishAllMotors(        // FAIL or SUCCESS
       int bQueryLocation)
            

<tr><td> MSL_FinishMotorMovement
 <td> "Finishes" a motor move sequence.  First verifies that the
           motor has been initialized, a move was pending, and no error
           occured.  This function should be called after calling
           MSL_WaitForMotorsDone and only if the move was successful.
           Motors which had an error should use MSL_CancelMotorMovement
           instead.
    <p>
           In addition, a query of the motor location is done if the
           query flag is set.  Typically, a query is not required--since
           the target position is valid if the move was successful.  The
           query mode would be used when moving to liquid.
 <td>
 <td class="func-call">
int MSLMOVE_API
    MSL_FinishMotorMovement(    // FAIL or SUCCESS
        int iMotor,             // motor handle
        int bQueryLocation)     // flag to query location after move
            
<tr><td>MSL_CancelMotorMovement
  <td> "Cancels" a motor move sequence.  Resets the next move pending
           parameter w/o changing the previous location.  Also, resets
           the active flag.
  <td> This function can be called in the following two cases:
   <ul><li>After MSL_SetupMotorNextMove and before  MSL_SendMotorsForward
     <li> After MSL_WaitForMotorsDone for a motor that had an error
          so that motor in error will not move again and again, or
          will not flag the error again even when it's not being moved.</ul>
 <td class="func-call">
int MSLMOVE_API
    MSL_CancelMotorMovement(    // FAIL or SUCCESS
        int iMotor)             // motor handle

<tr><td>MSL_SendMotorsBackward
 <td> Sends motor parameters to the CAN driver in preparation for
        for a move back to the previous known location.  Only motors
        which are initialized and have the next move initialized
        (via MSL_SetMotorNextMove) are serviced.  All motors will
        move to their previous location on the next MSL_StartMovement call.
   <td>
           Prior to sending any commands to the CAN driver, any
           pending faults are first cleared via MSL_ClearMotorMoveError.
 <td class="func-call">
int MSLMOVE_API
    MSL_SendMotorsBackward(     // FAIL or SUCCESS
        void)
            

<tr><td> MSL_SetPumpNextMove
 <td> Sets the target location, speed, ramp, pre-move and post-move
           delays, and valve position for the next move.  This function
           verifies that the pump has been initialized and the target
           location is within the pump range.  If the speed or ramp is
           zero, the pump default speed or ramp is used.
 <td> Although the valve position is passed here, it is no longer
           required due to the way the new pump DSP firmware works.
           Previously, the valve position and pump position could both
           be sent, then one "go" command issued--the firmware took care
           of positioning the valves first, and then the pumps.  Now,
           the valves must be positioned first, and then when complete,
           the pumps can be positioned.
   <p>
           Thus, the bTurnValveOnly parameter now has a slightly
           different meaning.  Set means turn the valves, and reset
           means position the pumps.  Now, MSL_SendPumpsFoward will
           only send CAN data if bTurnValveOnly is reset.  And,
           MSL_StartMovementPumps will now either send a "go" for the
           pumps, or a valve position command for the valves.
 <td class="func-call">
int MSLMOVE_API
    MSL_SetPumpNextMove(        // FAIL or SUCCESS
        int iPump,              // pump handle
        int iTargetValve,       // valve position in degrees:
                                    // VALVE_SYRINGE_TO_TIP (0)
                                    // VALVE_PERIPUMP_TO_TIP (90)
                                    // VALVE_PERIPUMP_TO_SYSLIQ (180) not used
                                    // VALVE_SYRINGE_TO_SYSLIQ (270)
        double dTargetLoc,      // absolute volume (ie, position) (ul)
        double dMoveSpeed,      // pump speed (ul/sec)
        double dMoveRamp,       // pump ramp (ul/sec/sec)
        int iPreDelay,          // pre-move delay (ms)
        int iPostDelay)         // post-move delay (ms)
            

<tr><td>MSL_SendPumpsForward
 <td> Sends pump parameters to the CAN driver in preparation for
           the next move.  Only pumps which are initialized and have
           the next move initialized (via MSL_SetPumpNextMove) are
           serviced.  All pumps will move to their target location on
           the next MSL_StartMovement call.
  <td>
           Prior to sending any commands to the CAN driver, any
           pending faults are first cleared via MSL_ClearPumpMoveError.
 <td class="func-call">
int MSLMOVE_API
   MSL_SendPumpsForward(    // FAIL or SUCCESS
        void)

<tr><td> MSL_StartMovementPumps
 <td> Start all loaded pumps (send "go" command).  If the
           bTurnValveOnly flag is set, send the appropriate turn
           valve command instead.  Called by MSL_StartMovement.
 <td>
 <td class="func-call">
    int MSL_StartMovementPumps(     // FAIL or SUCCESS
        void)
            

<tr><td>MSL_WaitForPumpsDone
 <td>Wait for all pumps to finish movement or timeout.  Only
           wait for pumps marked active and without error.
 <td>
 <td class="func-call">
int MSLMOVE_API
    MSL_WaitForPumpsDone(   // FAIL, SUCCESS, USER_ABORT, COM_ERROR, MOVE_ERROR
        int iMinTimeOut)    // minimum wait in sec before timeout

<tr><td> MSL_FinishAllPumps
 <td> "Finishes" the pump move sequence for all pumps that have
           been initialized, a move pending, and no error.  This
           function should be called after calling MSL_WaitForPumpsDone
           and only if all the pump moves were successful.  If any
           errors occured, MSL_CancelPumpMovement should be used for
           pumps with the error, and MSL_FinishPumpMovement for the
           pumps w/o an error.
 <td>
           A query of the pump location is done if the
           query flag is set.  Typically, a query is not required--since
           the target position is valid if the move was successful.  This
           flag is more useful for motors, where the location is not
           known when using LLS.
  <p>
           In addition, it makes no sense to request a query when
           positioning valves.
 <td class="func-call">
int MSLMOVE_API
    MSL_FinishAllPumps(         // FAIL or SUCCESS
        int bQueryLocation)

<tr><td> MSL_FinishPumpMovement
 <td> "Finishes" a pump move sequence.  First verifies that the
           pump has been initialized, a move was pending, and no error
           occured.  This function should be called after calling
           MSL_WaitForPumpsDone and only if the move was successful.
           Pumps which had an error should use MSL_CancelPumpMovement
           instead.
 <td>
           A query of the pump location is done if the
           query flag is set.  Typically, a query is not required--since
           the target position is valid if the move was successful.  This
           flag is more useful for motors, where the location is not
           known when using LLS.
   <p>
           In addition, it makes no sense to request a query when
           positioning valves.
 <td class="func-call">
int MSLMOVE_API
    MSL_FinishPumpMovement(     // FAIL or SUCCESS
        int iPump,              // pump handle
        int bQueryLocation)     // flag to query pump location

<tr><td>MSL_CancelPumpMovement
 <td> "Cancels" a pump move sequence.  Resets the next move pending
           parameter w/o changing the previous location.  Also, resets
           the active flag so that subsequent calls to wait for pumps
           done will not flag the error again.
 <td> This function can be called in the following two cases:
  <ul><li>After MSL_SetupPumpNextMove and before MSL_SendPumpsForward
    <li> After MSL_WaitForPumpsDone for a pump that had an error
               so that pump in error will not move again and again
  </ul>
 <td class="func-call">
int MSLMOVE_API
    MSL_CancelPumpMovement(     // FAIL or SUCCESS
        int iPump)              // pump handle

<tr><td colspan="4" class="sectionheader"> File Functions
<tr><td colspan="4">
<pre>
/******************************************************************************
MSLFILE.C:  MSL File Function Module


Comma-Delimited File Functions:
------------------------------
MSL_GetFileLines        Gets the number of text lines (or records) in the file.
MSL_GetFileLong         Gets an integer from a certain record and field in the file (aka MSL_GetFileInt)
MSL_GetFileDouble       Gets an double from a certain record and field in the file
MSL_GetFileString       Gets an string from a certain record and field in the file
MSL_GetFileRecord       Gets an entire record
MSL_GetFileSearch       Searches for a string contained in a certain field in the file
MSL_GetFileClose        Closes the currently open file (if any; files are opened automatically)
MSL_GetFileDelimitor    Gets the current file dilimiter (the comma character is the default)
MSL_SetFileDelimitor    Sets the curreny file dilimiter (does not affect the file itself)

Keyword=Value File Functions:
----------------------------
MSL_GetKeyword          Returns the value of the specified keyword.
MSL_WriteKeyword        Writes the specified keyword value.

Misc. Functions:
---------------
MSL_WriteFile           Similar to an fprintf() except the file name is passed rather
                        than a file pointer.

</pre>
<tr><td> MSL_GetFileLines
 <td>Get number of lines in a file.  Can also return the maximum
           fields found in all the records.
 <td>
 <td class="func-call">
   int MSL_GetFileLines(       // returns 0 if no file or no lines in file
                               //  else returns number of lines in file
       char *pszFilename,      // filename to check
       int  *iMaxFields)       // Maximum fields found while scanning file
                               //  (use NULL if don't care)

<tr><td> MSL_GetFileLong
 <td> Get a long from a file.
 <td>  Redirection is permitted via @(filename.typ;line;field), within
           a target file line/field.
   <p>     Can be called as MSL_GetFileLong(filename,line,fieldname),
           if file used contains @fieldname1,fieldname2,...fieldnameN
           definition on the first file line.
  <p>     Line and field numbers are zero based (0-n).
 <td class="func-call">
    long MSL_GetFileLong(       // returns a long value, 0 if error
        char *pszFilename,      // filename from which to derive a value
        int iLine,              // line in filename to derive value
        int iField)             // field in filename to derive value
                                //  (could be a number or name)

<tr><td> MSL_GetFileDouble
 <td> Get a double from a file.
 <td>  Redirection is permitted via @(filename.typ;line;field), within
           a target file line/field.
   <p>    Can be called as MSL_GetFileDouble(filename,line,fieldname),
           if file used contains @fieldname1,fieldname2,...fieldnameN
           definition on the first file line.
   <p>   Line and field numbers are zero based (0-n).
 <td class="func-call">
    double MSL_GetFileDouble(   // returns a double value, 0.0 if error
        char *pszFilename,      // filename from which to derive a value
        int iLine,              // line in filename to derive value
        int iField)             // field in filename to derive value
                                //  (could be a number or name)
<tr><td rowspan="2"> MSL_GetFileString
 <td> Get a string from a file.
 <td> Redirection is permitted via @(filename.typ;line;field), within
           a target file line/field.
  <p>    Can be called as MSL_GetFileString(filename,line,fieldname),
           if file used contains @fieldname1,fieldname2,...fieldnameN
           definition on the first file line.
  <p>  Line and field numbers are zero based (0-n).
 <td class="func-call">
   void *MSL_GetFileString(    // returns a pointer to string, or a pointer
                               //  to an empty ("") string if error
       char *pszFilename,      // filename from which to derive a value
       int iLine,              // line in filename to derive value
       int iField)             // field in filename to derive value
                               //  (could be a number or name)
<tr><td colspan="3">Example:
  <pre>
     char buf[80];
     char *ptr;
     ptr = MSL_GetFileString("testfile.dat", 5, "sample_id");
     strncpy(buf, ptr, 80);
     buf[80-1] = 0;
 </pre>

<tr><td>MSL_GetFileRecord
 <td>Get a record from a file.
 <td> Line number is zero based (0-n).
 <td class="func-call">
    void *MSL_GetFileRecord(    // returns a pointer to string, or a pointer
                                //  to an empty ("") string if error
        char *pszFilename,      // filename from which to read record
        int iLine)              // line (record) in filename to read

<tr><td> MSL_GetFileSearch
 <td>Get line containing field with matching string.
 <td><ul><li>String match strips leading controls and whitespace.
   <li> Field number is zero based (0-n). </ul>
 <td class="func-call">
    int MSL_GetFileSearch(      // returns line #, or -1 if no match found
        char *pszFilename,      // filename to check
        char *pszString,        // case independant string to match
        int iField)             // field in filename to scan
                                //  (could be a number or name)
<tr><td> MSL_GetFileDelimiter
 <td> Returns the current file delimiter
 <td>
 <td class="func-call">
   int MSL_GetFileDelimiter()  // returns the file delimiter

<tr><td>MSL_SetFileDelimiter
 <td>Sets the file delimiter and returns the previous delimiter.
 <td>
 <td class="func-call">
   int MSL_SetFileDelimiter(   // returns the previous file delimiter
       int nNewDelimiter )     // the new file delimiter;

<tr><td>MSL_GetFileClose
 <td> Close current MSL_GetFile...() file.
 <td> You only need to call this function if you need to use the
           file handle used by the MSL_GetFile...() functions for some
           other purpose.  For example, you need all 15 file handles
           available to MSL.  Or, another program running simultaneously
           needs to open a shared file.
 <td class="func-call">
    void *MSL_GetFileClose()        // returns NULL
            

<tr><td>MSL_WriteFile
 <td>Open a file append mode, and write a printf line to it.
 <td><ul><li>Calls:      MSL_StringFormat, strlen, open, write, close
  <li>This function uses an internal buffer for printf output,
           the maximum output line is 1024 bytes.
  <li> All file output is handle based binary mode. </ul>
 <td class="func-call">
    int MSL_WriteFile(          // return "errno" on error, else returns 0
        char *pszFilename,      // fully qualified filename for file write
        char *pszArguments,     // printf style control string
        ...)                    // printf style arguments
            

<tr><td rowspan="2">MSL_GetKeyword
 <td>Reads keyword value from file into buffer.
 <td><ul><li>Whitespace is generally ignored.  Any whitespace, before or
           after a keyword or value is stripped.  If the string containing
           the value is all whitespace, the variables for most types
           will remain at their defaults.  Boolean and string variables
           are exceptions.
   <p>
           Boolean variables are set to FALSE (0) if the string is
           made up entirely of whitespace characters or the first
           letters of the string exactly match one of the following
           words: 0, NO, OFF, or FALSE (case-insensitive).
   <p>
           String variables whose value is NULL, will result in a
           zero length string.
   <li>If the value is an array, the type field contains the number
           of elements in bits 8-15.  The line will a set of comma
           delimited values which are read in as above.  The array
           feature does not work with strings.
   <li>Maximum length of a line in file is 1024 characters.  Strings
           exceeding either the maximum or the caller's buffer size will
           be read, but truncated.
   <li>If the filename does not contain a full path to the file, the
           current directory is assumed.
   <li> Data type "float" is not supported--only "double".
	</ul>
 <td class="func-call">
    int MSL_GetKeyword (    // TRUE (success) or FALSE
        char *pszFilename,  // name of keyword file
        char *pszSection,   // name of section
        char *pszKeyword,   // name of keyword
        char *pszType,      // "String","Int","Long","Double","Bool","Char"
                            // Only casefolded first letter of type is used
        int  iElements,     // number of target elements (not bytes)
        void *pvTarget,     // destination buffer
        int iTargetSize)    // destination buffer size
<tr><td colspan="3">
Examples:
<pre>
String:
   MSL_GetKeyword("packard.ini", "MultiProbe", "keyword_string",
          "String", 1, value_string, sizeof(value_string));

Integer Array of 5:
   MSL_GetKeyword("packard.ini", "MultiProbe", "step values",
          "Int", 5, steps, sizeof(int));

Return  If the file, section, or keyword could not be found, the
Value:  return value is FALSE.  If the keyword is found, the return
      value is TRUE (even if the value is NULL).
</pre>


<tr><td rowspan="2"> MSL_WriteKeyword
 <td> Change or add a keyword in a file with a new value.
 <td><ul><li> If the filename does not contain a full path to the file,
           the current directory is assumed.
  <li> If the file does not exist, it is created.
  <li> The section name must be provided.  If it does not exist, it is created.
  <li> If the keyword is NULL, the entire section is deleted!
  <li> If the value (argument list) is NULL, the keyword is deleted.
           A null string can be used to blank the keyword.
  <li> Maximum length of a line in file is 1024 characters.
  </ul>
 <td class="func-call">
    int MSL_WriteKeyword (  // True (success) or FALSE
        char *pszFilename,  // name of keyword file
        char *pszSection,   // name of section
        char *pszKeyword,   // name of keyword
        char *pszArguments, // printf style argument for value
        ...)                // additional printf style arguments
<tr><td colspan="3">
Examples:
<pre>
sprintf style parameter:
      MSL_WriteKeyword("packard.ini", "MultiProbe", "Run Number",
           "%d by %s", run, user_name);

delete keyword:
      MSL_WriteKeyword("sample.dat", "MySection", "keyword", NULL);
           
blank keyword value:
      MSL_WriteKeyword("sample.dat", "MySection", "keyword", "");
</pre>

<tr><td colspan="4" class="sectionheader"> Timer Functions
<tr><td> MSL_TimeMarkerFind
 <td>To return a pointer to the time marker structure of the
       specified name.  Returns NULL if the marker was not found
 <td>
 <td class="func-call">
   MP2_TIME_MARKER* MSL_TimeMarkerFind(
                 char *pszName,         // Name of the time marker to find.
                                        //  If a matching marker is not found
                                        //  the current time will be loaded
                                        //  into pTime.
                 struct tm *pTime )     // Time stored in the timer marker
                                        //  structure
 <tr><td> MSL_TimeMarkerCreate
  <td>To create/update a time marker.
  <td>
 <td class="func-call">
    int MSL_TimeMarkerCreate(
      char *pszName )         // Name of the time marker to create.  If a marker
                              //  with the same name already exists, it will
                              //  be loaded with the current local time.
 <tr><td> MSL_TimeMarkerDelete
 <td> To delete the specified time marker
 <td>
 <td class="func-call">
   int MSL_TimeMarkerDelete(
     char *pszName )         // Name of the time marker to delete.  If "" or
                             //  NULL, all time markers will be deleted.
 <tr><td>MSL_TimeMarkerLook
  <td>To return the time the specified marker was created/updated.
  <td>
 <td class="func-call">
   int MSL_TimeMarkerLook(
      char *pszName,          // Name of the time marker.  If "" or NULL, the
                              //  current local time will be returned.
      MP2_DATE* pDate,        // Year, month, day
      MP2_TIME* pTime )       // Hour, minute, second.
 <tr><td> MSL_TimeMarkerWait
  <td>To pause the script until the specified time past when the
            marker was created has expired.
  <td> If the name of a user function is passed, it will be called
           at the specified interval (dInterval) while the timer is
           active and one last time after the timer expires.  The user
           function will be passed a pointer to the time marker structure
           MP2_TIME_MARKER.  If the user function returns a value
           less than zero, the timer will be stopped.
 <td class="func-call">
  int MSL_TimeMarkerWait(<br>
    char *pszName,          // Name of the time marker.  If "" or NULL, the<br>
                            //  current local time will be used.<br>
    MP2_TIME* pTime,        // Time period beyond the marker time to wait<br>
    char *pszUserFunct,     // Optional user function to invoke instead of<br>
                            //  displaying a dialog box<br>
    double dInterval )      // Interval (in floating seconds) in which to<br>
                            //  invoke the user function during the wait<br>
                            //  period.

 <tr><td> MSL_DateTimeWait
   <td> To pause the script until the specified date time has arrived.
   <td> If the name of a user function is passed, it will be called
           at the specified interval (dInterval) while the timer is
           active and one last time after the timer expires.  The user
           function will be passed a pointer to the time marker structure
           MP2_TIME_MARKER.  If the user function returns a value
           less than zero, the timer will be stopped.
 <td class="func-call">
int MSL_DateTimeWait(
    char *pszName,          // Name to place on the dialog box banner
    MP2_DATE* pDate,        // Date to wait for
    MP2_TIME* pTime,        // Time of day to wait for
    char *pszUserFunct,     // Optional user function to invoke instead of
                            //  displaying a dialog box
    double dInterval )      // Interval (in floating seconds) in which to
                            //  invoke the user function during the wait
                            //  period.

 <tr><td> MSL_DateToSeconds
  <td> To convert an MP2_DATE structure into a number of seconds
         passed 1/1/1970.
 <td>
 <td class="func-call">
int MSL_DateToSeconds( MP2_DATE* pDate )    // Date to be converted

 <tr><td> MSL_SecondsToDate
  <td> To convert a number of seconds (passed 1/1/1970) into
       the mYear, nMonth and nDay values of the MP2_DATE structure.
  <td>
 <td class="func-call">
void MSL_SecondsToDate(
        int nSeconds,       // Seconds to be converted
     MP2_DATE* pDate )      // Ptr to structure where date to be loaded

 <tr><td> MSL_DateToString
   <td>To convert an MP2_DATE structure into a ASCII string
           according to the local settings.
   <td>
 <td class="func-call">
void MSL_DateToString(
     MP2_DATE* pDate,       // Date to be converted to a string
     char* pszDate,         // Address of text buffer to receive the date
     UINT  nMaxLen )        // Max length of the buffer

 <tr><td> MSL_StringToDate
   <td>  To convert an ASCII string into a date value assuming the
           local format.
   <td>
   <td class="func-call">
BOOL MSL_StringToDate(      // Returns FALSE if unsuccessful
     char* pszDate,         // Address of text buffer from which date is to
                            //  be extracted
                            //  If NULL or zero length, the current date will
                            //  be used.
     MP2_DATE* pDate )      // Ptr to structure where date to be loaded

 <tr><td> MSL_TimeToSeconds
  <td> To convert an MP2_TIME structure into a number of seconds.
  <td> Requires that the bPeriod member of the MP2_TIME structure
            be set appropriately so that time of day or a time period
            is used
  <td class="func-call">
int MSL_TimeToSeconds( MP2_TIME* pTime )      // Date to be converted

 <tr><td> MSL_SecondsToTime
   <td> To convert a number of seconds into a time of day or
          time period.
   <td> Requires that the bPeriod member of the MP2_TIME structure
            be set appropriately so that time of day or a time period
           is generated.
 <td class="func-call">
void MSL_SecondsToTime(
      int nSeconds,         // Seconds to be converted
     MP2_TIME* pTime )      // Ptr to structure where date to be loaded

 <tr><td> MSL_TimeToString
   <td>To convert an MP2_TIME structure into a ASCII string.
   <td> Requires that the bPeriod member of the MP2_TIME structure
                be set appropriately so that time of day or a time period
                is used
 <td class="func-call">
void MSL_TimeToString(
     MP2_TIME* pTime,       // Time to be converted to a string
     char* pszTime,         // Address of text buffer to receive the date
     UINT  nMaxLen )        // Max length of the buffer

<tr><td>MSL_StringToTime
   <td> To convert an ASCII string into a time value.
   <td> Requires that the bPeriod member of the MP2_TIME structure
                be set appropriately so that time of day or a time period
                is used
 <td class="func-call">
BOOL MSL_StringToTime(      // Returns FALSE if unsuccessful
     char* pszTime,         // Address of text buffer from which time is to
                            //  be extracted
                            //  If NULL or zero length, the current time will
                            //  be used (or zero for time periods).
     MP2_TIME* pTime )      // Ptr to structure where date to be loaded
</table>


<h2>MultiPROBE II Script Language DLL Extensions (MSLEXT.CSV)</h2>
<p>
Use the file MSLEXT.CSV to specify C callable functions that you
wish to invoke from a MSL script.
<p>
A single record must exist for function.  You may insert comment record(s)
anywhere in this file by making the first character in the record an
exclamation point (!).
<p>
Several fields (columns) are required for each function.  The columns are
comma delimited.  A description of what is expected in each column follows.
<p>
Functions in this file may be directly selectable from WinPREP's user
procedure.  However, any functions that require argument(s) of types
other than "int", "long" or "double" would not be selectable unless
column 6 is defined (see below).
<table>
<tr><th>Column  <th>    Description
<tr><td>  1     <td>The name of the function as you wish to reference
it from the MSL script.
<tr><td>  2     <td>The name of the function as it exists in the DLL.  If you are
not sure of the DLL name.  Highlight the DLL file from the
Windows NT Explorer and click the right mouse btn.  Select the
"Quick View" item.  This will display a window which contains
a description of the DLL contents.  Scroll down to the section
titled "Export Table" to view the DLL's functions which are
callable from the outside.
<tr><td> 3     <td>  The DLL file name.
<tr><td> 4    <td>  The function's return type:
 <table>
 <tr><th> Type <th>   Description
 <tr><td>   2  <td> void
 <tr><td>   3  <td> char
 <tr><td>   4  <td> short
 <tr><td>   5  <td> unsigned char
 <tr><td>   6  <td> unsigned short
 <tr><td>   7  <td> unsigned int
 <tr><td>   8  <td> unsigned long
     (Note: long and int are the same size in Windows NT)
 <tr><td>   9  <td> int
 <tr><td>  10  <td> pointer to anything
 <tr><td>  14  <td> double
 </table>
<tr><td>  5    <td>  The function's argument list.  This is a series of characters
that imply the type, order and number of arguments which the
function expects.  The field may be blank for functions that
require no arguments.  The signed/unsigned nature of the argument
is not considered.
 <table>
 <tr><th> Character  <th> Description
 <tr><td>    i       <td>    int
 <tr><td>    l       <td>    long    (Note: long and int are the same size in Windows NT)
 <tr><td>    d       <td>    double
 <tr><td>    c       <td>    char
 <tr><td>    p       <td>    pointer to anything
 <tr><td>    .       <td>    variable argument list
 </table>

     For example, a DLL function with the following prototype...
<pre>
     int MyDllFunct( int nWidgets, double dCost, char *pszName );
</pre>
 ...would have the following record in this file...
<p>
<code> MyDllFunct, MyDllFunct, MYDLL.DLL, 9, idp </code>
<tr><td>     6       <td>   Optional argument description function.
If a name appears here, the WinPREP application will attempt to
invoke it with the following arguments.
<pre>
   ArgDescFunct( int nArgs, MSLEXT_ARG_DEF* pArgArray );
</pre>
 <table>
 <tr><td>  nArgs     <td> The number of arguments that were specified in col 5
 <tr><td>  pArgArray <td>  A pointer to an array of MSLEXT_ARG_DEF structures
                         (1 for each argument).  MSLEXT_ARG_DEF is defined
                          in WinPREP.s
 </table>
           The function should place the argument name, a default value
           and a description into each element of the argument array.
           This information will be displayed when the user selects the
           function (defined in Col 1) from the user procedure's overview
           page (in the WinPREP application).
<p>
           If you do not supply a function for describing the arguments,
           the function (defined in Col 1) may still be selectable from
           WinPREP, however, the argument names will be "Arg1", "Arg2",
           etc.

<tr><td> 7      <td>Optional argument value editor function.  If a name appears here,
             the WinPREP application will enable a properties button that
             appears on the user procedure's overview page.  If the user
             clicks on that function, the editor function will be invoked.
             Upon return, the argument values displayed in the user procedure
             overview page will be refreshed.
             This value editor function would be invoked with the following
             arguments.
<pre>
     ArgEditFunct( int nArgs, MSLEXT_ARG_DEF* pArgArray, HWND hOwner );
</pre>
 <table>
 <tr><td> nArgs  <td>The number of arguments that were specified in col 5
 <tr><td> pArgArray <td>  A pointer to an array of MSLEXT_ARG_DEF structures
                        (1 for each argument).  MSLEXT_ARG_DEF is defined
                        in WinPREP.s
 <tr><td> hOwner   <td>    Window handle of the user procedure's overview dialog.
 </table>
             The intent here is to provide a more application specific
             method for editing the argument values that will be used
             at runtime to invoke the function (define in Col 1).
</table>
<pre>
Script Function Name, DLL Internal Function Name,  DLL Name,  Return, Arguments, Arg Desc. Funct,   Properties Funct
</pre>

<h1>Glossary</h1>
<p>
A <a href="MassPREPglossary.html">separate document</a> contains a glossary for the special terminology of the MassPREP.
</body>
</html>

